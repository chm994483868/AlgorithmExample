/* 
  StudyList.strings
  Algorithm_C

  Created by CHM on 2020/7/10.
  Copyright © 2020 CHM. All rights reserved.
*/

7.9:
1. 学习 C++ 的 vector、stack、queue 文档，牢记它们的使用，为下面的算法使用做好铺垫。
2. 反转二叉树。
3. 找到链表中倒数第 k 个节点。
4. 青蛙跳台阶。
5. 重写赋值运算符。
6. 数组中重复的数字。
7. 堆排序加深理解以及其它排序的复习。

7.10:
1. 学习 C++ 中哈希表的使用。
2. 不修改数组找出重复的数字。
3. 二维数组中的查找。
4. 替换空格。
5. 往链表的末尾添加一个节点。
6. 在链表中找到第一个含有某值的节点并删除该节点。
7. 从尾到头打印链表。
8. 根据前序和中序结果重建二叉树。

7.11:
1. 二叉树的下一个节点。
2. 用两个栈实现队列。
3. 算法和数据操作部分提到了回溯法和动态规划以及贪婪算法，对它们的认识需要加强。
4. 递归和循环。递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，
   都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而且往栈里压入数据和弹出数据都需要时间。
5. 递归和非递归的方式求 1 + 2 + 3 + ... + n 的值。
6. 斐波那契数列。

7.12:
1. 全部复习默写。
...

7.13:

// 对任何问题首先两个思考：
// 1. 判断入参是否合规。
// 2. 准备下个函数要使用的参数。

1. 旋转数组的最小数字。
2. 对公司员工年龄排序（计数排序）。
3. 矩阵中的路径。
4. 机器人的运动范围。
5. 剪绳子。
6. 二进制中 1 的个数。
7. 用一条语句判断一个整数是不是 2 整数次方。一个整数如果是 2 的整数次方，那么它的二进制表示中有且只有一位是 1，其它位都是 0。
if ((n - 1) & n == 0) { return true;}
8. 输入两个整数 m 和 n，计算需要改变 m 的二进制表示中的多少位才能得到 n。
比如 10 的二进制表示为 1010，13 的二进制表示为 1101，需要改变 1010 中的 3 位才能得到 1101。
我们可以分为两步解决这个问题：第一步求这两个数的异或；第二步统计异或结果中 1 的位数。（相同为假，不同为真）。

7.14:
1. 求数值的整数次方，不得使用库函数，不需要考虑大数问题。
2. 打印从 1 到最大的 n 位数。
3. 删除链表的节点。
4. 删除链表中重复的节点。

7.15:
1. 删除链表的节点。
2. 删除链表中重复的节点。
3. 正则表达式匹配。

7.16:
1. 表示数值的字符串。
2. 调整数组顺序使奇数位于偶数前面。
3. 链表中倒数第 K 个节点。
4. 链表中环的入口节点。
5. 反转链表。
6. 合并两个排序的链表。
7. 树的子结构。

7.17:
1. 二叉树的镜像（反转二叉树）。
2. 对称的二叉树。
3. 顺时针打印矩阵。
4. 包含 min 函数的栈。
5. 栈的压入、弹出序列。
6. 从上到下打印二叉树。
7. 分行从上到下打印二叉树。
8. 之字形打印二叉树。

7.18:
1. 之字形打印二叉树。
2. 二叉搜索树的后序遍历序列。
3. 二叉树中和为某一值的路径。

7.19:
1. 45-56 题 Review。
1. 01-56 题 Review。

7.20:
1. 复杂链表的复制。
2. 二叉搜索树与双向链表。
3. 序列化二叉树。
4. 字符串的排列。

7.21:
1. 数组中出现次数超过一半的数字。
2. 看递归看了一下午。好难🦷🦷🦷🦷！

7.22:
1. 数组中出现次数超过一半的数字。
2. 最小的 K 个数。
3. 数据流中的中位数。
4. 连续子数组的最大和。
5. 1~n 整数中 1 出现的次数。

7.23: 当前的任务是持续向下刷题，尽快把所有题目过一遍，(这个过是很深入的学习研究过才算过，不是一扫而过)
1. 数字序列中某一位的数字
2. 把数组拼成最小的数。
3. 把数字翻译成字符串。
4. 礼物的最大价值。
5. 最长不含重复字符的子字符串。
6. 丑数。

7.24:
1. 第一个只出现一次的字符。
2. 字符流中第一个只出现一次的字符。
3. 数组中的逆序对。（解法可由归并排序迁移）
4. 两个链表的第一个公共节点。
5. 在排序数组中查找数字。
6. 0～n-1 中缺失的数字。
7. 数组中数值和下标相等的元素。
8. 二叉搜索树的第 k 大节点。
9. 二叉树的深度。
10. 平衡二叉树。
11. 数组中数字出现的次数。

7.25:
1. 数组中唯一只出现一次的数字。
2. 和为 s 的数字。
3. 和为 s 的连续正数序列。
4. 翻转字符串。
5. 左旋转字符串。
6. 队列的最大值。
7. 定义队列实现函数 max 返回最大值，要求 max、push_back、pop_front 的时间复杂度都是 O(1);

7.26:
1. n 个🎲的点数。（真的太难了，看了 4 个小时了，还是没有眉目，先过一下，先看下一题。）
2. 扑克牌中的顺子。
3. 圆圈中最后剩下的数字。
4. 股票的最大利润。
5. 求 1+2+...+n。
6. 不用加减乘除做加法。
7. 构建乘积数组。
8. 把字符串转换成整数。
9. 树中两个节点的最低公共祖先。

7.27: 启动总复习计划
1. 赋值运算符函数。
2. 找出数组中重复的数字。
3. 不修改数组找出重复的数字。
4. 二维数组中的查找。
5. 请实现一个函数，把字符串中的每个空格替换成。
6. 从尾到头打印链表。
7. 重建二叉树。

7.28:
1. 二叉树的下一个节点。
2. 用两个栈实现队列。
3. 用两个队列实现栈。
4. 斐波那契数列。
5. 快速排序和员工年龄排序。
6. 旋转数组的最小数字。
7. 矩阵中的路径。
8. 机器人的运动范围。
9. 二进制中 1 的个数。
10. 数值的整数次方。
11. 打印1到最大的n位数。

7.29:
1. 
