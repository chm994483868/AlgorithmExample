//
//  Review_2.cpp
//  Algorithm_C
//
//  Created by HM C on 2020/7/12.
//  Copyright © 2020 CHM. All rights reserved.
//

#include <stdio.h>
#include <iostream>

#include <string.h>
#include <vector>
#include <stack>
#include <queue>
#include <list>
#include <algorithm>

using namespace std;

namespace Review_2 {

// 01. 冒泡排序 O(n*n)
// 每一趟循环比较相邻元素大小交换位置，每次把一个最大值或最小值放在数组一端

// 02. 插入排序 O(n*n)
// 开始时假设左边第一元素为已排序数组，然后每次从右边取一个元素插入左边的已排序数组


// 03. 选择排序 O(n*n)
// 假设左边序列已排序，每次从数组中找到一个最小值放在左边已排序数组的最后


// 04. 希尔排序 O(n*n)
// 优化插入排序

// 05. 希尔排序优化 O(n*n)

// 06. 快速排序 O(n*logn)
// 挖坑 + 分治法

// 07. 归并排序 O(n*logn)
// 先把无序数组拆开成一个个有序数组，然后再把它们按大小顺序合并起来

// 08. 堆排序 O(n*logn)
// 首先把数据堆化，（堆是一种特殊的二叉树，根节点总是大于或者小于左右子节点，而且如果只有一个节点时，总是左子节点不为空）
// 然后把根元素和数组最后一个元素交换位置，即把最大或者最小的元素置于数组末尾，然后把数组交换 0 位剩下的数据继续堆化
// 然后循环重复上面的步骤，知道 0 1 交换

// 09. 堆排序（素燕）O(n*logn)

// 10. 反转二叉树（递归）

// 11. 反转二叉树（栈或者队列）

// 12. 找到链表中倒数第 k 个节点 O(n)

// 13. 重写赋值运算符

// 14. 找到数组中重复的数字 O(1) O(n)

// 15. 找到数组中重复的数字 O(n) O(n)

// 16. 不修改数组找出重复的数字 O(1) O(n*logn)

// 17. 二维数组中查找数字

// 18. 替换字符串中的空格 O(n)

// 19. 往链表的末尾添加一个结点

// 20. 从链表中找到第一个含有某值的节点并删除该节点

// 21. 从尾到头打印链表（递归）（递归在本质上就是一个栈结构）

// 22. 从尾到头打印链表（非递归）

// 23. 根据二叉树前序遍历和中序遍历的结果，重建该二叉树

// 24. 二叉树的下一个节点

// 25. 用两个栈实现队列

// 26. 用两个队列实现栈

// 27. 求 1 + 2 + ... + n 的值（递归和非递归）

// 28. 斐波那契数列（递归和非递归）

// 29. 对公司员工年龄排序（计数排序）。
// 假设员工的年龄范围是 0-99，准备一个长度是 100 的数组，数组元素都被初始为 0
// 然后遍历所有员工，把员工的年龄作为下标，把对应的元素做自增操作，即统计每个年龄的员工数量
// 然后从小到大开始便利所有年龄，把每个年龄的人从小到大排列，
//（涉及到同一个年龄的人有多个人时，同一个数字依次向后排）

// 30. 旋转数组的最小数字。
// 旋转后的数组总是前半部分大于后半部分
// 特殊情况1: 当旋转的部分长度为 0 时，indexMid = index1，即第一个元素即为最小元素
// 特殊情况2: 当 index1 index2 indexMid 的元素相等时只能顺序查找最小元素
// 正常情况下 index1 从第一个元素开始，index2 从最后一个元素开始，
// indexMid = ((index2 - index1) >> 1) + index1, 如果 indexMid 大于 index1 即表示 indexMid 位于前半部分，index1 赋值为 indexMid，否则 index2 赋值为 indexMid
// 类似二分查找持续下去

// 31. 矩阵中的路径。

// 32. 机器人的运动范围。

// 33. 剪绳子。

// 34. 二进制中 1 的个数。

// 35. 求数值的整数次方，不得使用库函数，不需要考虑大数问题。

// 36. 打印从 1 到最大的 n 位数。

// 37. 删除链表的节点。

// 38. 删除链表中重复的节点。

// 39. 正则表达式匹配。

// 40. 表示数值的字符串。

// 41. 调整数组顺序使奇数位于偶数前面。

// 42. 链表中倒数第 k 个节点。

// 43. 链表中环的入口节点。

// 44. 反转链表。

// 45. 合并两个排序的链表。

// 46. 树的子结构。

// 47. 二叉树的镜像（反转二叉树）。

// 48. 对称的二叉树。

// 49. 顺时针打印矩阵。

// 50. 包含 min 函数的栈。

// 51. 栈的压入、弹出序列。

// 52. 从上到下打印二叉树。

// 53. 分行从上到下打印二叉树。

// 54. 之字形打印二叉树。

// 55. 二叉搜索树的后序遍历序列。

// 56. 二叉树中和为某一值的路径。

// 57. 复杂链表的复制。

// 58. 二叉搜索树与双向链表。

// 59. 序列化二叉树。

// 60. 字符串的排列。

// 61. 数组中出现次数超过一半的数字。

// 62. 最小的 K 个数。

// 63. 数据流中的中位数。

}
