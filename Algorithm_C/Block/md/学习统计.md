> 还是有必要把每天的学习的内容都记录下来，有利于回顾复习，不然的话好像每天什么都没做一样。

## 8.20
1. 补充 `constexpr` 关键字代码，使用时需要引入头文件 `#include <iostream>`。
2. `SideTable` 第一个成员变量: 
  `spinlock_t slock`->
  `using spinlock_t = mutex_tt<LOCKDEBUG>;`->
  `struct mutex_tt : nocopy_t { os_unfair_lock mLock; ... };`->
  `typedef struct os_unfair_lock_s { uint32t _os_unfair_lock_opaque; } os_unfair_lock, *os_unfair_lock_t;`
3. `os_unfair_lock` 是用来代替 `OSSpinLock` 的，那先学习 `OSSpinLock`
4. 要使用 `OSSpinLock` 需要先引入 `#import <libkern/OSAtomic.h>`，看到 `usr/include/libkern/OSSpinLockDeprecated.h` 名字后面的 `Deprecated` 强烈的提示着我们 `OSSpinLock` 以及被废弃了，不要再用它了。
5. 查看 `OSSpinLockDeprecated.h` 文件里面到处是 `Deprecated` 和呼吁我们使用 `os_unfair_lock`。
6. 看到 `volatile` 关键字，展开学习。
7. 看到 `noexcept` 关键字，展开学习。
8. 回到 `OSSpinLockDeprecated.h` 继续学习，先看一下自旋锁的常规使用。
9. 完成了 `OSSpinLock` 的头文件分析和使用，查找为什么它存在线程安全问题。

## 8.21
1. 分析昨天的疑惑，为什么⏰线程和⚽️线程为什么其中一个打印会小于 10000，而另一个可以大于 10000，还有判断 `atomic` 会不会影响结果打印。
2. 先学会使用 `os_unfair_lock`，在逐行分析它的代码。
3. 因为锁的代码示例都会用到 `dispatch_async()` 这里引出了一个知识点，在它的  block 里面是否需要使用 `__weak typeof(self) weakSelf = self;`，这里涉及的问题很多，需要先研究一下。
4. `__weak`使用时定义在 block 内部的 `__strong` 变量依然用 `self`。
    ```objective-c
    // 以后使用 block 的标准模式
    __weak typeof(self) _self = self;
    ^{
        __strong typeof(_self) self = _self;
        if (!self) return;
        // do something 
        /// ...
    };
    ```
5. [iOS 属性引用self->,self.xx与_xx的区别](https://www.jianshu.com/p/62ed57cedf11)
6. `os_unfair_lock` API 摘录。
7. 阅读 `pthread_mutex_t` 使用。

## 8.22
1. 补充 `os_unfair_t` 流程图。
2. 使用 `pthread_mutex_t`。
3. `pthread_mutex_t`示例代码以及源码文档。
4. `NSLock`。

## 8.23
1. `iOS_NSRecursiveLock`。
2. `iOS_NSCondition`。
3. `iOS_NSConditionLock`。
4. `iOS_@synchronized`。
5. `iOS_dispatch_semaphore`。
6. `pthread_rwlock_t`。

## 8.24 
1. iOS中的锁学习总结完毕。
2. 切回到 runtime 切回到 weak 关键字。

## 后面没有再统计不是因为停止了学习，是因为写这个统计太费时间了。

### 下面待学习
1. category 原理
2. 关联对象原理 
3. 多线程使用以及原理。

3. __weak 修饰变量和 weak 属性中的 weak 同义。
4. load_weak 是用于读取 weak 变量。

8.27
[内存管理](https://www.jianshu.com/p/8d742a44f0da)
[C语言中的位屏蔽(bit masking)是怎么回事](http://c.biancheng.net/cpp/html/1611.html)

8.28
1. 如果弱引用比对象提前释放了，那 `weak_entry_t` 中的弱引用的指针的哈希数组怎么处理？


# 10.12
今天开始要开启一个崭新的状态一个崭新的阶段！不要高估自己的定力妄想自己能抵制诱惑，正确的做法是直接远离诱惑！
要相信自己，相信自己所有的目标都能达到！也同时不要害怕时间流逝，不要害怕时间不够，只管踏踏实实一步一步来完成每一个小目标，最后一定会累积成山，最终能达到什么高度就交给时间来验证吧，最后做到无怨无悔即可。

1): 晚上回去把落地扇收到盒子里。窗帘拉开，从此不拉窗帘。
2): 把 B 站的游戏 UP 取关，不再看 B 站和直播。
3): 再这样下去你的人生就真的的废了。从今天开始一定要保持百分之百的专注！


KCObjcTest was compiled with optimization - stepping may behave oddly; variables may not be available.
(lldb) x/5gx cls
0x100003778: 0x0000000100003750 0x00000001003ef140
0x100003788: 0x0000000101146b90 0x0001803400000003
0x100003798: 0x00000001011466d4
(lldb) p (class_data_bits_t *)0x100003798
(class_data_bits_t *) $1 = 0x0000000100003798
(lldb) p $1->data()
(class_rw_t *) $2 = 0x00000001011466d0
(lldb) p *$2
(class_rw_t) $3 = {
  flags = 2148007936
  version = 0
  witness = 1
  ro = 0x00000001000034b8
  methods = {
    list_array_tt<method_t, method_list_t> = {
       = {
        list = 0x0000000100003500
        arrayAndFlag = 4294980864
      }
    }
  }
  properties = {
    list_array_tt<property_t, property_list_t> = {
       = {
        list = 0x0000000100003698
        arrayAndFlag = 4294981272
      }
    }
  }
  protocols = {
    list_array_tt<unsigned long, protocol_list_t> = {
       = {
        list = 0x00000001000034a0
        arrayAndFlag = 4294980768
      }
    }
  }
  firstSubclass = nil
  nextSiblingClass = NSUUID
  demangledName = 0x0000000000000000
}
(lldb) p $2->ro
(const class_ro_t *) $4 = 0x00000001000034b8
(lldb) p *$4
(const class_ro_t) $5 = {
  flags = 388
  instanceStart = 8
  instanceSize = 40
  reserved = 0
  ivarLayout = 0x0000000100001e8e "\x04"
  name = 0x0000000100001e85 "LGPerson"
  baseMethodList = 0x0000000100003500
  baseProtocols = 0x00000001000034a0
  ivars = 0x0000000100003610
  weakIvarLayout = 0x0000000000000000
  baseProperties = 0x0000000100003698
  _swiftMetadataInitializer_NEVER_USE = {}
}
(lldb) p $5->baseProtocols
(protocol_list_t *const) $6 = 0x00000001000034a0
  Fix-it applied, fixed expression was: 
    $5.baseProtocols
(lldb) p *$6
(protocol_list_t) $7 = (count = 1, list = protocol_ref_t [] @ 0x00007fc04f1909f8)
(lldb) p $6->list[0]
(protocol_ref_t) $8 = 4294981640
(lldb) p (protocol_t *)4294981640
(protocol_t *) $9 = 0x0000000100003808
(lldb) p *$9
(protocol_t) $10 = {
  objc_object = {
    isa = {
      cls = Protocol
      bits = 4299092168
       = {
        nonpointer = 0
        has_assoc = 0
        has_cxx_dtor = 0
        shiftcls = 537386521
        magic = 0
        weakly_referenced = 0
        deallocating = 0
        has_sidetable_rc = 0
        extra_rc = 0
      }
    }
  }
  mangledName = 0x0000000100001e76 "CustomProtocol"
  protocols = 0x0000000100003328
  instanceMethods = 0x0000000100003340
  classMethods = 0x0000000100003390
  optionalInstanceMethods = 0x00000001000033b0
  optionalClassMethods = 0x00000001000033d0
  instanceProperties = 0x00000001000033f0
  size = 96
  flags = 0
  _extendedMethodTypes = 0x0000000100003408
  _demangledName = 0x0000000000000000
  _classProperties = 0x0000000000000000
}
(lldb) p (protocol_list_t *)0x0000000100003328
(protocol_list_t *) $11 = 0x0000000100003328
(lldb) p *$11
(protocol_list_t) $12 = (count = 1, list = protocol_ref_t [] @ 0x00007fc04f4b3708)
(lldb) p $12->list[0]
(protocol_ref_t) $13 = 4294981544
  Fix-it applied, fixed expression was: 
    $12.list[0]
(lldb) p (protocol_t *)4294981544
(protocol_t *) $14 = 0x00000001000037a8
(lldb) p *$14
(protocol_t) $15 = {
  objc_object = {
    isa = {
      cls = nil
      bits = 0
       = {
        nonpointer = 0
        has_assoc = 0
        has_cxx_dtor = 0
        shiftcls = 0
        magic = 0
        weakly_referenced = 0
        deallocating = 0
        has_sidetable_rc = 0
        extra_rc = 0
      }
    }
  }
  mangledName = 0x0000000100001e6d "NSObject"
  protocols = 0x0000000000000000
  instanceMethods = 0x0000000100003050
  classMethods = 0x0000000000000000
  optionalInstanceMethods = 0x0000000100003220
  optionalClassMethods = 0x0000000000000000
  instanceProperties = 0x0000000100003240
  size = 96
  flags = 0
  _extendedMethodTypes = 0x0000000100003288
  _demangledName = 0x0000000000000000
  _classProperties = 0x0000000000000000
}
(lldb) p $10.instanceMethods
(method_list_t *) $16 = 0x0000000100003340
(lldb) p *$16
(method_list_t) $17 = {
  entsize_list_tt<method_t, method_list_t, 3> = {
    entsizeAndFlags = 24
    count = 3
    first = {
      name = "insMethod"
      types = 0x0000000100001f3d "v16@0:8"
      imp = 0x0000000000000000
    }
  }
}
(lldb) p $10.classMethods
(method_list_t *) $18 = 0x0000000100003390
(lldb) p *$18
(method_list_t) $19 = {
  entsize_list_tt<method_t, method_list_t, 3> = {
    entsizeAndFlags = 24
    count = 1
    first = {
      name = "classMethod"
      types = 0x0000000100001f3d "v16@0:8"
      imp = 0x0000000000000000
    }
  }
}
(lldb) p $10.optionalInstanceMethods
(method_list_t *) $20 = 0x00000001000033b0
(lldb) p $20
(method_list_t *) $20 = 0x00000001000033b0
(lldb) p *$20
(method_list_t) $21 = {
  entsize_list_tt<method_t, method_list_t, 3> = {
    entsizeAndFlags = 24
    count = 1
    first = {
      name = "insMethod_optional"
      types = 0x0000000100001f3d "v16@0:8"
      imp = 0x0000000000000000
    }
  }
}
(lldb) p $10.optionalClassMethods
(method_list_t *) $22 = 0x00000001000033d0
(lldb) p *$22
(method_list_t) $23 = {
  entsize_list_tt<method_t, method_list_t, 3> = {
    entsizeAndFlags = 24
    count = 1
    first = {
      name = "classMethod_optional"
      types = 0x0000000100001f3d "v16@0:8"
      imp = 0x0000000000000000
    }
  }
}
(lldb) p $10.instanceProperties
(property_list_t *) $24 = 0x00000001000033f0
(lldb) p *$24
(property_list_t) $25 = {
  entsize_list_tt<property_t, property_list_t, 0> = {
    entsizeAndFlags = 16
    count = 1
    first = (name = "protocolProperty", attributes = "T@\"NSObject\",&,N")
  }
}
(lldb) p $10.size
(uint32_t) $26 = 96
(lldb) p $10->nameForLogging()
(const char *) $27 = 0x0000000100001e76 "CustomProtocol"
  Fix-it applied, fixed expression was: 
    $10.nameForLogging()
(lldb) p $2->ro_or_rw_ext
error: no member named 'ro_or_rw_ext' in 'class_rw_t'
(lldb) p *$2
(class_rw_t) $28 = {
  flags = 2148007936
  version = 0
  witness = 1
  ro = 0x00000001000034b8
  methods = {
    list_array_tt<method_t, method_list_t> = {
       = {
        list = 0x0000000100003500
        arrayAndFlag = 4294980864
      }
    }
  }
  properties = {
    list_array_tt<property_t, property_list_t> = {
       = {
        list = 0x0000000100003698
        arrayAndFlag = 4294981272
      }
    }
  }
  protocols = {
    list_array_tt<unsigned long, protocol_list_t> = {
       = {
        list = 0x00000001000034a0
        arrayAndFlag = 4294980768
      }
    }
  }
  firstSubclass = nil
  nextSiblingClass = NSUUID
  demangledName = 0x0000000000000000
}
(lldb) 
