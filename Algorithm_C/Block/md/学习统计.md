> 还是有必要把每天的学习的内容都记录下来，有利于回顾复习，不然的话好像每天什么都没做一样。

## 8.20
1. 补充 `constexpr` 关键字代码，使用时需要引入头文件 `#include <iostream>`。
2. `SideTable` 第一个成员变量: 
  `spinlock_t slock`->
  `using spinlock_t = mutex_tt<LOCKDEBUG>;`->
  `struct mutex_tt : nocopy_t { os_unfair_lock mLock; ... };`->
  `typedef struct os_unfair_lock_s { uint32t _os_unfair_lock_opaque; } os_unfair_lock, *os_unfair_lock_t;`
3. `os_unfair_lock` 是用来代替 `OSSpinLock` 的，那先学习 `OSSpinLock`
4. 要使用 `OSSpinLock` 需要先引入 `#import <libkern/OSAtomic.h>`，看到 `usr/include/libkern/OSSpinLockDeprecated.h` 名字后面的 `Deprecated` 强烈的提示着我们 `OSSpinLock` 以及被废弃了，不要再用它了。
5. 查看 `OSSpinLockDeprecated.h` 文件里面到处是 `Deprecated` 和呼吁我们使用 `os_unfair_lock`。
6. 看到 `volatile` 关键字，展开学习。
7. 看到 `noexcept` 关键字，展开学习。
8. 回到 `OSSpinLockDeprecated.h` 继续学习，先看一下自旋锁的常规使用。
9. 完成了 `OSSpinLock` 的头文件分析和使用，查找为什么它存在线程安全问题。

## 8.21
1. 分析昨天的疑惑，为什么⏰线程和⚽️线程为什么其中一个打印会小于 10000，而另一个可以大于 10000，还有判断 `atomic` 会不会影响结果打印。
2. 先学会使用 `os_unfair_lock`，在逐行分析它的代码。
3. 因为锁的代码示例都会用到 `dispatch_async()` 这里引出了一个知识点，在它的  block 里面是否需要使用 `__weak typeof(self) weakSelf = self;`，这里涉及的问题很多，需要先研究一下。
4. `__weak`使用时定义在 block 内部的 `__strong` 变量依然用 `self`。
    ```objective-c
    // 以后使用 block 的标准模式
    __weak typeof(self) _self = self;
    ^{
        __strong typeof(_self) self = _self;
        if (!self) return;
        // do something 
        /// ...
    };
    ```
5. [iOS 属性引用self->,self.xx与_xx的区别](https://www.jianshu.com/p/62ed57cedf11)
6. `os_unfair_lock` API 摘录。
7. 阅读 `pthread_mutex_t` 使用。

## 8.22
1. 补充 `os_unfair_t` 流程图。
2. 使用 `pthread_mutex_t`。
3. `pthread_mutex_t`示例代码以及源码文档。
4. `NSLock`。

## 8.23
1. `iOS_NSRecursiveLock`。
2. `iOS_NSCondition`。
3. `iOS_NSConditionLock`。
4. `iOS_@synchronized`。
5. `iOS_dispatch_semaphore`。
6. `pthread_rwlock_t`。

## 8.24 
1. iOS中的锁学习总结完毕。
2. 切回到 runtime 切回到 weak 关键字。

## 后面没有再统计不是因为停止了学习，是因为写这个统计太费时间了。

### 下面待学习
1. category 原理
2. 关联对象原理 
3. 多线程使用以及原理。

3. __weak 修饰变量和 weak 属性中的 weak 同义。
4. load_weak 是用于读取 weak 变量。

8.27
[内存管理](https://www.jianshu.com/p/8d742a44f0da)
[C语言中的位屏蔽(bit masking)是怎么回事](http://c.biancheng.net/cpp/html/1611.html)

8.28
1. 如果弱引用比对象提前释放了，那 `weak_entry_t` 中的弱引用的指针的哈希数组怎么处理？


+ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
类对象的地址后三位是 `0`，类对象是遵循 `8` 字节对齐。
类的成员变量内存对齐是采用 `8` 字节对齐，类实例化时分配空间时则是遵循 `16` 字节对齐。

# 10.12
今天开始要开启一个崭新的状态一个崭新的阶段！不要高估自己的定力妄想自己能抵制诱惑，正确的做法是直接远离诱惑！
要相信自己，相信自己所有的目标都能达到！也同时不要害怕时间流逝，不要害怕时间不够，只管踏踏实实一步一步来完成每一个小目标，最后一定会累积成山，最终能达到什么高度就交给时间来验证吧，最后做到无怨无悔即可。

1): 晚上回去把落地扇收到盒子里。窗帘拉开，从此不拉窗帘。
2): 把 B 站的游戏 UP 取关，不再看 B 站和直播。
3): 再这样下去你的人生就真的的废了。从今天开始一定要保持百分之百的专注！

# 40 分钟用来看方法的慢速查找吧！

+ [iOS基础(九) - load和initialize的实现原理](https://www.jianshu.com/p/66b366ed850e)

# 10.15 进入第一阶段复习
# （10.20 GCD 线程 KVC KVO RunLoop 编译到启动的流程 -- 待完成）
# 10.29 第一阶段复习完毕


# （GCD 线程 KVC KVO RunLoop 编译到启动的流程 -- 待完成）
# （GCD 线程 KVC KVO RunLoop 编译到启动的流程 -- 待完成）
# （GCD 线程 KVC KVO RunLoop 编译到启动的流程 -- 待完成）


### CFRunLoopSourceRef（struct \__CFRunLoopSource *）
&emsp;CFRunLoopSourceRef 是事件源（输入源），通过源码可以发现它内部的 `_context` 联合体中有两个成员变量 `version0` 和 `version1`，它们正分别对应了我们前面提到过多次的 source0 和 source1。

&emsp;
```c++
typedef struct __CFRunLoopSource * CFRunLoopSourceRef;

struct __CFRunLoopSource {
    CFRuntimeBase _base; // 所有 CF "instances" 都是从这个结构开始的
    uint32_t _bits;
    pthread_mutex_t _lock; // 互斥锁
    CFIndex _order; /* immutable */ source 的优先级，值为小，优先级越高
    CFMutableBagRef _runLoops; // run loop 集合
    union {
        CFRunLoopSourceContext version0; /* immutable, except invalidation */
        CFRunLoopSourceContext1 version1; /* immutable, except invalidation */
    } _context;
};
```
&emsp;当 \__CFRunLoopSource 表示 source0 的数据结构时 `_context` 中使用 `CFRunLoopSourceContext version0`，下面是 CFRunLoopSourceContext 的定义。 
```c++
// #if __LLP64__
//  typedef unsigned long long CFOptionFlags;
//  typedef unsigned long long CFHashCode;
//  typedef signed long long CFIndex;
// #else
//  typedef unsigned long CFOptionFlags;
//  typedef unsigned long CFHashCode;
//  typedef signed long CFIndex;
// #endif

typedef struct {
    CFIndex version;
    void * info; // source 的信息
    const void *(*retain)(const void *info); // retain 函数
    void (*release)(const void *info); // release 函数
    CFStringRef (*copyDescription)(const void *info); // 
    Boolean (*equal)(const void *info1, const void *info2); // 判断 source 相等的函数
    CFHashCode (*hash)(const void *info); // 哈希函数
    
    // 上面是 CFRunLoopSourceContext 和 CFRunLoopSourceContext1 的基础内容双方完成等同，
    // 两者的区别主要在下面，同时它们也表示了 source0 和 source1 的不同功能。
    
    void (*schedule)(void *info, CFRunLoopRef rl, CFStringRef mode); // 当 source 加入到 run loop 时触发的回调函数
    void (*cancel)(void *info, CFRunLoopRef rl, CFStringRef mode); // 当 source 从 run loop 中移除时触发的回调函数
    void (*perform)(void *info); // source 要执行的任务块，当 source 事件被触发时的回调, 使用 CFRunLoopSourceSignal 函数触发
} CFRunLoopSourceContext;
```
&emsp;当 \__CFRunLoopSource 表示 source1 的数据结构时 `_context` 中使用 `CFRunLoopSourceContext1 version1`，下面是 CFRunLoopSourceContext1 的定义。
```c++
typedef struct {
    CFIndex version;
    void * info; // source 的信息
    const void *(*retain)(const void *info); // retain 函数
    void (*release)(const void *info); // release 函数
    CFStringRef (*copyDescription)(const void *info); // 
    Boolean (*equal)(const void *info1, const void *info2); // 判断 source 相等的函数
    CFHashCode (*hash)(const void *info); // 哈希函数
    
    // 上面是 CFRunLoopSourceContext 和 CFRunLoopSourceContext1 的基础内容双方完成等同，
    // 两者的区别主要在下面，同时它们也表示了 source0 和 source1 的不同功能。
    
#if (TARGET_OS_MAC && !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)
    mach_port_t (*getPort)(void *info); // getPort 函数指针，用于当 source 被添加到 run loop 中的时候，从该函数中获取具体的 mach_port_t 对象.
    void * (*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info); // perform 函数指针即指向 run loop 被唤醒后将要处理的事情
#else
    void * (*getPort)(void *info);
    void (*perform)(void *info);
#endif
} CFRunLoopSourceContext1;
```
### CFRunLoopObserverRef（struct \__CFRunLoopObserver *）
&emsp;CFRunLoopObserverRef 是观察者，每个 observer 都包含了一个回调（函数指针），当 run loop 的状态发生变化时，观察者就能通过回调接受到这个变化。主要是用来向外界报告 run loop 当前的状态的更改。
```c++
typedef struct __CFRunLoopObserver * CFRunLoopObserverRef;

struct __CFRunLoopObserver {
    CFRuntimeBase _base; // 所有 CF "instances" 都是从这个结构开始的
    pthread_mutex_t _lock; // 互斥锁
    CFRunLoopRef _runLoop; // observer 所观察的 run loop
    CFIndex _rlCount; // observer 观察了多少个 run loop
    CFOptionFlags _activities; /* immutable */ // 所监听的事件，通过位异或，可以监听多种事件，_activities 用来说明要观察 runloop 的哪些状态，一旦指定了就不可变。
    CFIndex _order; /* immutable */ // observer 优先级
    
    // typedef void (*CFRunLoopObserverCallBack)(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info);
    CFRunLoopObserverCallBack _callout; /* immutable */ // observer 回调函数，观察到 run loop 状态变化后的回调
    
    CFRunLoopObserverContext _context; /* immutable, except invalidation */ // observer 上下文
};
```
&emsp;observer 也包含一个回调函数，在监听的 run loop 状态出现时触发该回调函数。run loop 对 observer 的使用逻辑，基本与 timer 一致，都需要指定 callback 函数，然后通过 context 可传递参数。

&emsp;`CFRunLoopActivity` 是一组枚举值用于表示 run loop 的活动。
```c++
/* Run Loop Observer Activities */
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL << 0), // 进入 RunLoop 循环(这里其实还没进入)
    kCFRunLoopBeforeTimers = (1UL << 1), // Run Loop 要处理 timer 了
    kCFRunLoopBeforeSources = (1UL << 2), // Run Loop 要处理 source 了
    kCFRunLoopBeforeWaiting = (1UL << 5), // Run Loop 要休眠了
    kCFRunLoopAfterWaiting = (1UL << 6), // Run Loop 醒了
    kCFRunLoopExit = (1UL << 7), // Run Loop 退出（和 kCFRunLoopEntry 对应，Entry 和 Exit 在每次 Run Loop 循环中仅调用一次，用于表示即将进入循环和退出循环。）
    kCFRunLoopAllActivities = 0x0FFFFFFFU
};
```
&emsp;CFRunLoopObserverContext 的定义。
```c++
typedef struct {
    CFIndex version;
    void * info;
    const void *(*retain)(const void *info);
    void (*release)(const void *info);
    CFStringRef (*copyDescription)(const void *info);
} CFRunLoopObserverContext;
```
### CFRunLoopTimerRef（struct \__CFRunLoopTimer *）
&emsp;NSTimer 是与 run loop 息息相关的，CFRunLoopTimerRef 与 NSTimer 是可以 toll-free bridged（免费桥接转换）的。当 timer 加到 run loop 的时候，run loop 会注册对应的触发时间点，时间到了，run loop 若处于休眠则会被唤醒，执行 timer 对应的回调函数。
```c++
typedef struct CF_BRIDGED_MUTABLE_TYPE(NSTimer) __CFRunLoopTimer * CFRunLoopTimerRef;

struct __CFRunLoopTimer {
    CFRuntimeBase _base; // 所有 CF "instances" 都是从这个结构开始的
    uint16_t _bits; // 标记 timer 的状态
    pthread_mutex_t _lock; // 互斥锁
    CFRunLoopRef _runLoop; // timer 对应的 run loop，注册在哪个 run loop 中
    CFMutableSetRef _rlModes; // timer 对应的 run loop modes，内部保存的也是 run loop mode 的名字，也验证了 timer 可以在多个 run loop mode 中使用
    CFAbsoluteTime _nextFireDate; // timer 的下次触发时机，每次触发后都会再次设置该值
    CFTimeInterval _interval; /* immutable */
    CFTimeInterval _tolerance; /* mutable */ // timer 的允许时间偏差
    uint64_t _fireTSR; /* TSR units */ // timer 本次需要被触发的时间
    CFIndex _order; /* immutable */
    
    // typedef void (*CFRunLoopTimerCallBack)(CFRunLoopTimerRef timer, void *info);
    CFRunLoopTimerCallBack _callout; /* immutable */ // timer 回调
    
    CFRunLoopTimerContext _context; /* immutable, except invalidation */ // timer 上下文，可用于传递参数到 timer 对象的回调函数中。
};
```
&emsp;CFRunLoopTimerContext 的定义。
```c++
typedef struct {
    CFIndex version;
    void * info;
    const void *(*retain)(const void *info);
    void (*release)(const void *info);
    CFStringRef (*copyDescription)(const void *info);
} CFRunLoopTimerContext;
```
&emsp;本篇主要内容聚焦在 run loop 获取（查找+创建）和 run loop mode 的获取（查找+创建），并大致看下 run loop mode item: CFRunLoopSourceRef、CFRunLoopObserverRef、CFRunLoopTimerRef 的结构定义，下篇我们再详细看它们的操作。






#### \__CFRunLoopFindMode
&emsp;`__CFRunLoopFindMode` 函数根据 modeName 从 rl 的 _modes 中找到其对应的 CFRunLoopModeRef，如果找到的话则加锁并返回。如果未找到，并且 create 为真的话，则新建 __CFRunLoopMode 加锁并返回，如果 create 为假的话，则返回 NULL。
```c++
static CFRunLoopModeRef __CFRunLoopFindMode(CFRunLoopRef rl, CFStringRef modeName, Boolean create) {
    // 用于检查给定的进程是否被分叉
    CHECK_FOR_FORK();
    
    // struct __CFRunLoopMode 结构体指针
    CFRunLoopModeRef rlm;
    
    // 创建一个 struct __CFRunLoopMode 结构体实例，
    // 并调用 memset 把 srlm 内存空间全部置为 0。
    struct __CFRunLoopMode srlm;
    memset(&srlm, 0, sizeof(srlm));
    
    // __kCFRunLoopModeTypeID 现在正是表示 CFRunLoopMode 类，实际值是 run loop mode 类在全局类表 __CFRuntimeClassTable 中的索引。
    
    // 前面 __CFRunLoopCreate 函数内部会调用 CFRunLoopGetTypeID() 函数，
    // 其内部是全局执行一次在 CF 运行时中注册两个新类 run loop（CFRunLoop）和 run loop mode（CFRunLoopMode），
    // 其中 __kCFRunLoopModeTypeID = _CFRuntimeRegisterClass(&__CFRunLoopModeClass)，那么 __kCFRunLoopModeTypeID 此时便是 run loop mode 类在全局类表中的索引。
    //（__CFRunLoopModeClass 可以理解为一个静态全局的 "类对象"（实际值是一个），_CFRuntimeRegisterClass 函数正是把它放进一个全局的 __CFRuntimeClassTable 类表中。）

    // 本身 srlm 是一片空白内存，现在相当于把 srlm 设置为一个 run loop mode 类的对象。 
    //（实际就是设置 CFRuntimeBase 的 _cfinfo 成员变量，srlm 里面目前包含的内容就是 run loop mode 的类信息。）
    _CFRuntimeSetInstanceTypeIDAndIsa(&srlm, __kCFRunLoopModeTypeID);
    
    // 把 srlm 的 mode 名称设置为入参 modeName
    srlm._name = modeName;
    
    // 从 rl->_modes 哈希表中找 &srlm 对应的 CFRunLoopModeRef
    rlm = (CFRunLoopModeRef)CFSetGetValue(rl->_modes, &srlm);
    
    // 如果找到了则加锁，然后返回 rlm。
    if (NULL != rlm) {
        __CFRunLoopModeLock(rlm);
        return rlm;
    }
    
    // 如果没有找到，并且 create 值为 false，则表示不进行创建，直接返回 NULL。
    if (!create) {
    return NULL;
    }
    
    // 创建一个 CFRunLoopMode 对并返回其地址
    rlm = (CFRunLoopModeRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopModeTypeID, sizeof(struct __CFRunLoopMode) - sizeof(CFRuntimeBase), NULL);
    
    // 如果 rlm 创建失败，则返回 NULL
    if (NULL == rlm) {
        return NULL;
    }
    
    // 初始化 rlm 的 pthread_mutex_t _lock 为一个互斥递归锁。
    //（__CFRunLoopLockInit 内部使用的 PTHREAD_MUTEX_RECURSIVE 表示递归锁，允许同一个线程对同一锁加锁多次，且需要对应次数的解锁操作）
    __CFRunLoopLockInit(&rlm->_lock);
    
    // 初始化 _name
    rlm->_name = CFStringCreateCopy(kCFAllocatorSystemDefault, modeName);
    
    // 下面是一组成员变量的初始赋值
    rlm->_stopped = false;
    rlm->_portToV1SourceMap = NULL;
    
    // _sources0、_sources1、_observers、_timers 初始状态都是空的
    rlm->_sources0 = NULL;
    rlm->_sources1 = NULL;
    rlm->_observers = NULL;
    rlm->_timers = NULL;
    
    rlm->_observerMask = 0;
    rlm->_portSet = __CFPortSetAllocate(); // CFSet 申请空间初始化
    rlm->_timerSoftDeadline = UINT64_MAX;
    rlm->_timerHardDeadline = UINT64_MAX;
    
    // ret 是一个临时变量初始值是 KERN_SUCCESS，用来表示向 rlm->_portSet 中添加 port 时的结果，
    // 如果添加失败的话，会直接 CRASH， 
    kern_return_t ret = KERN_SUCCESS;
    
#if USE_DISPATCH_SOURCE_FOR_TIMERS
    // macOS 下，使用 dispatch_source 构造 timer
    
    // _timerFired 首先赋值为 false，然后在 timer 的回调函数执行的时候会赋值为 true
    rlm->_timerFired = false;
    
    // 队列
    rlm->_queue = _dispatch_runloop_root_queue_create_4CF("Run Loop Mode Queue", 0);
    
    // 构建 queuePort，入参是 mode 的 _queue
    mach_port_t queuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm->_queue);
    
    // 如果 queuePort 为 NULL，则 crash。（无法创建运行循环模式队列端口。）
    if (queuePort == MACH_PORT_NULL) CRASH("*** Unable to create run loop mode queue port. (%d) ***", -1);
    
    // 构建 dispatch_source 类型使用的是 DISPATCH_SOURCE_TYPE_TIMER，表示是一个 timer
    rlm->_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, rlm->_queue);
    
    // 这里为了在下面的 block 内部修改 _timerFired 的值，用了一个 __block 指针变量。（觉的如果这里只是改值，感觉用指针就够了可以不用 __block 修饰）
    // 当 _timerSource（计时器）回调时会执行这个 block。
    __block Boolean *timerFiredPointer = &(rlm->_timerFired);
    dispatch_source_set_event_handler(rlm->_timerSource, ^{
        *timerFiredPointer = true;
    });
    
    // Set timer to far out there. The unique leeway makes this timer easy to spot in debug output.
    // 将计时器设置在远处。独特的回旋余地使该计时器易于发现调试输出。（从 DISPATCH_TIME_FOREVER 启动，DISPATCH_TIME_FOREVER 为时间间隔）
    _dispatch_source_set_runloop_timer_4CF(rlm->_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 321);
    // 启动
    dispatch_resume(rlm->_timerSource);
    
    // 把运行循环模式队列端口 queuePort 添加到 rlm 的 _portSet（端口集合）中。
    ret = __CFPortSetInsert(queuePort, rlm->_portSet);
    // 如果添加失败则 crash。（无法将计时器端口插入端口集中。）
    if (KERN_SUCCESS != ret) CRASH("*** Unable to insert timer port into port set. (%d) ***", ret);
#endif

#if USE_MK_TIMER_TOO
    // mk 构造 timer
    
    // 构建 timer 端口
    rlm->_timerPort = mk_timer_create();
    // 同样把 rlm 的 _timerPort 添加到 rlm 的 _portSet（端口集合）中。
    ret = __CFPortSetInsert(rlm->_timerPort, rlm->_portSet);
    // 如果添加失败则 crash。（无法将计时器端口插入端口集中。）
    if (KERN_SUCCESS != ret) CRASH("*** Unable to insert timer port into port set. (%d) ***", ret);
#endif
    
    // 然后这里把 rl 的 _wakeUpPort 也添加到 rlm 的 _portSet（端口集合）中。
    //（这里要特别注意一下，run loop 的 _wakeUpPort 会被插入到所有 mode 的 _portSet 中。）
    ret = __CFPortSetInsert(rl->_wakeUpPort, rlm->_portSet);
    // 如果添加失败则 crash。（无法将唤醒端口插入端口集中。）
    if (KERN_SUCCESS != ret) CRASH("*** Unable to insert wake up port into port set. (%d) ***", ret);
    
#if DEPLOYMENT_TARGET_WINDOWS
    rlm->_msgQMask = 0;
    rlm->_msgPump = NULL;
#endif

    // 这里把 rlm 添加到 rl 的 _modes 中，
    //（本质是把 rlm 添加到 _modes 哈希表中）
    CFSetAddValue(rl->_modes, rlm);
    
    // 释放，rlm 被 rl->_modes 持有，并不会被销毁
    CFRelease(rlm);
    
    // 加锁，然后返回 rlm
    __CFRunLoopModeLock(rlm);    /* return mode locked */
    return rlm;
}
```
&emsp;其中 `ret = __CFPortSetInsert(rl->_wakeUpPort, rlm->_portSet)` 会把 run loop 对象的 `_wakeUpPort` 添加到每个 run loop mode 对象的 `_portSet` 端口集合里。即当一个 run loop 有多个 run loop mode 时，那么每个 run loop mode 都会有 run loop 的 `_wakeUpPort`。

&emsp;在 macOS 下 run loop mode 的 `_timerSource` 的计时器的回调事件内部会把 run loop mode 的 `_timerFired` 字段置为 true，表示计时器被触发。

&emsp;run loop mode 创建好了，看到 source/timer/observer 三者对应的 `_sources0`、`_sources1`、`_observers`、`_timers` 四个字段初始状态都是空，需要我们自己添加 run loop mode item，它们在代码层中对应的数据类型分别是: CFRunLoopSourceRef、CFRunLoopObserverRef、CFRunLoopTimerRef，那么就把它们放在下篇进行分析吧！
