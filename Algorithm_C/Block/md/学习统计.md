> 还是有必要把每天的学习的内容都记录下来，有利于回顾复习，不然的话好像每天什么都没做一样。

## 8.20
1. 补充 `constexpr` 关键字代码，使用时需要引入头文件 `#include <iostream>`。
2. `SideTable` 第一个成员变量: 
  `spinlock_t slock`->
  `using spinlock_t = mutex_tt<LOCKDEBUG>;`->
  `struct mutex_tt : nocopy_t { os_unfair_lock mLock; ... };`->
  `typedef struct os_unfair_lock_s { uint32t _os_unfair_lock_opaque; } os_unfair_lock, *os_unfair_lock_t;`
3. `os_unfair_lock` 是用来代替 `OSSpinLock` 的，那先学习 `OSSpinLock`
4. 要使用 `OSSpinLock` 需要先引入 `#import <libkern/OSAtomic.h>`，看到 `usr/include/libkern/OSSpinLockDeprecated.h` 名字后面的 `Deprecated` 强烈的提示着我们 `OSSpinLock` 以及被废弃了，不要再用它了。
5. 查看 `OSSpinLockDeprecated.h` 文件里面到处是 `Deprecated` 和呼吁我们使用 `os_unfair_lock`。
6. 看到 `volatile` 关键字，展开学习。
7. 看到 `noexcept` 关键字，展开学习。
8. 回到 `OSSpinLockDeprecated.h` 继续学习，先看一下自旋锁的常规使用。
9. 完成了 `OSSpinLock` 的头文件分析和使用，查找为什么它存在线程安全问题。

## 8.21
1. 分析昨天的疑惑，为什么⏰线程和⚽️线程为什么其中一个打印会小于 10000，而另一个可以大于 10000，还有判断 `atomic` 会不会影响结果打印。
2. 先学会使用 `os_unfair_lock`，在逐行分析它的代码。
3. 因为锁的代码示例都会用到 `dispatch_async()` 这里引出了一个知识点，在它的  block 里面是否需要使用 `__weak typeof(self) weakSelf = self;`，这里涉及的问题很多，需要先研究一下。
4. `__weak`使用时定义在 block 内部的 `__strong` 变量依然用 `self`。
    ```objective-c
    // 以后使用 block 的标准模式
    __weak typeof(self) _self = self;
    ^{
        __strong typeof(_self) self = _self;
        if (!self) return;
        // do something 
        /// ...
    };
    ```
5. [iOS 属性引用self->,self.xx与_xx的区别](https://www.jianshu.com/p/62ed57cedf11)
6. `os_unfair_lock` API 摘录。
7. 阅读 `pthread_mutex_t` 使用。

## 8.22
1. 补充 `os_unfair_t` 流程图。
2. 使用 `pthread_mutex_t`。
3. `pthread_mutex_t`示例代码以及源码文档。
4. `NSLock`。

## 8.23
1. `iOS_NSRecursiveLock`。
2. `iOS_NSCondition`。
3. `iOS_NSConditionLock`。
4. `iOS_@synchronized`。
5. `iOS_dispatch_semaphore`。
6. `pthread_rwlock_t`。

## 8.24 
1. iOS中的锁学习总结完毕。
2. 切回到 runtime 切回到 weak 关键字。

## 后面没有再统计不是因为停止了学习，是因为写这个统计太费时间了。


## 面试题收集
+ [iOS面试题：阿里-P6一面-参考思路](http://www.cocoachina.com/articles/21362)
