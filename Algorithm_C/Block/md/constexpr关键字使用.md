# constexpr关键字使用
`constexpr` 是 `C++ 11` 开始提出的关键字，其意义与 `C++ 14` 版本有一些区别。
`C++ 11` 中的 `constexpr` 指定的函数返回值和参数必须是字面值，而且必须有且只有一行 `return` 代码。这个给函数的实现带来了更多的限制，比如通常只能通过三目运算符 + 递归来计算返回的字面值。
`C++ 14` 中修改了规则，只要保证返回值和参数是字面值就行了，函数体中可以加入更多的语句，方便了灵活的计算。

很多人把 `constexpr` 和 `const` 相比较。

其实，`const` 并不能代表 “常量”，它**仅仅是对变量的一个修饰**，告诉编译器这个变量只能被初始化，且不能被直接修改（实际上可以通过堆栈溢出等方式修改）。而这个变量的值，可以在运行时也可以在编译时指定。

`constexpr` 可以用来修饰变量、函数、构造函数。一旦以上任何元素被 `constexpr` 修饰，那么等于说是告诉编译器 “请大胆地将我看成编译时就能得出常量值的表达式去优化我”。如：
```c++
    
```
对于 `func()`，胆小的编译器并没有足够的胆量去做编译优化，哪怕函数体就一句 return 字面值。而：
```c++

```
则编译通过，编译期大胆的将 func() 做了优化，在编译期就确定了 func 计算出的值 10，而无需等到运行时再去计算。

这就是 `constexpr` 的第一个作用：给编译器足够的信心在编译期去做被 `constexpr` 修饰的表达式的优化。

`constexpr` 还有另外一个特性，虽然它本身的作用之一就是希望程序员能给编译器做优化的信心，但它却猜到了自己可能会被程序员欺骗，而编译器并不会对此 "恼羞成怒"中止编译，如：

程序员告诉编译器尽管信心十足地把 func 当做是编译期就能计算出值的程序，但却欺骗了它，程序员最终并没有传递一个常量字面量值到该函数。没有被编译器中止编译并报错的原因在于编译器并没有 100% 相信程序员，当其检测到 func 的参数是一个常量字面值的时候，编译器才会去对其优化，否则，依然会将计算任务留给运行时。
基于这个特性，constexpr 还可以被用来实现编译期的 type traits，比如 STL 中的 is_const 的完整实现:
```c++

```
**参考链接:🔗**
[C++11/14 constexpr 用法](https://www.jianshu.com/p/34a2a79ea947)
