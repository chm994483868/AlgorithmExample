# iOS 2021 面试前的准备（总结各知识点方便面试前快速复习使用）（七）

## 55. 类声明中的成员变量的顺序和实际的成员变量的顺序。
&emsp;在面向对象（`oop`）的编程语言中，每一个对象都是某个类的实例。在 `Objective-C` 中，所有对象的本质都是一个 `objc_object` 结构体，且每个实例对象的第一个成员变量都是 `isa`，可从中取得该对象所属的类，每一个类描述了一系列它的实例对象的信息，包括对象占用内存大小、成员变量列表、该对象能执行的函数列表...等等。

&emsp;在一个类的实例对象的内存布局中，第一个成员变量是 `isa`，然后根据该对象所属类的继承体系依次对成员变量排序，排列顺序是: 根类的成员变量、父类的成员变量、最后才是自己的成员变量，且每个类定义中的成员变量（仅包含使用 `@property` 声明属性后由编译器生成的同名的 _成员变量）相互之间的顺序可能会与定义时的顺序不同，编译器会在内存对齐的原则下对类定义时的成员变量的顺序做出优化，保证内存占用最少。（还会涉及到 `.h` 中的成员变量和属性，`.m` 中 `extension` 中添加的成员变量和属性，它们之间的排序顺序）

&emsp;验证代码:
```objective-c
// SubObject 类定义
@interface SubObject : BaseObject {
    NSArray *cus_array;
}

@property (nonatomic, assign) int cus_int;
@property (nonatomic, assign) double cus_dou;
@property (nonatomic, assign) int cus_int2;
@property (nonatomic, copy) NSString *cus_string;

@end

// 添加断点，控制台打印
(lldb) p *sub
(SubObject) $2 = {
  BaseObject = {
    NSObject = {
      isa = SubObject
    }
    baseString = nil
    _baseArray = nil
  }
  cus_array = nil
  _cus_int = 0
  _cus_int2 = 0
  _cus_dou = 0
  _cus_string = nil
}
```
&emsp;可看到 `NSObject` 的 `isa` 在最前面，然后是 `BaseObject` 的成员变量，最后才是 `SubObject` 的成员变量，然后注意 `_cus_int2` 跑到了 `_cus_dou` 前面，而在类定义时 `cus_dou` 属性是在 `cus_int2` 属性前面的。（由于内存对齐时不用再为 `double` 补位，这样至少减少了 4 个字节的内存浪费）

***

## 56. 为什么不能动态的给类添加成员变量却可以添加方法？
&emsp;类的成员变量布局以及其实例对象大小在编译时就已确定，设想一下，如果 `Objective-C` 中允许给一个类动态添加成员变量，会带来一个问题：为基类动态增加成员变量会导致所有已创建出的子类实例都无法使用。我们所说的 “类的实例”（对象），指的是一块内存区域，里面存储了 `isa` 指针和所有的成员变量。所以假如允许动态修改类已固定的成员变量的布局，那么那些已经创建出的对象就不符合类的定义了，那就变成无效对象了。而方法的定义都是在类对象或元类对象中的，不管如何增删方法，都不会影响对象的内存布局，已经创建出的对象仍然可以正常使用。

***

## 57. ISA_BITFIELD 中的 64 位分别都代表什么。
```c++
#   define ISA_BITFIELD                                                      \
      // 表示 isa 中只是存放的 Class cls 指针还是包含更多信息的 bits
      uintptr_t nonpointer        : 1;                                       \
      // 标记该对象是否有关联对象，如果没有的话对象能更快的销毁，
      // 如果有的话销毁前会调用 _object_remove_assocations 函数根据关联策略循环释放每个关联对象
      uintptr_t has_assoc         : 1;                                       \
      // 标记该对象所属类是否有自定义的 C++ 析构函数，如果没有的话对象能更快销毁，
      // 如果有的话对象销毁前会调用 object_cxxDestruct 函数去执行该类的析构函数
      uintptr_t has_cxx_dtor      : 1;                                       \
      // isa & ISA_MASK 得出该实例对象所属的的类的地址
      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \
      // 用于调试器判断当前对象是真的对象还是没有初始化的空间
      uintptr_t magic             : 6;                                       \
      // 标记该对象是否有弱引用，如果没有的话对象能更快销毁，
      // 如果有的话对象销毁前会调用 weak_clear_no_lock 函数把该对象的弱引用置为 nil，
      // 并调用 weak_entry_remove 把对象的 entry 从 weak_table 中移除
      uintptr_t weakly_referenced : 1;                                       \
      // 标记该对象是否正在执行销毁
      uintptr_t deallocating      : 1;                                       \
      // 标记 refcnts 中是否也有保存实例对象的引用计数，当 extra_rc 溢出时会把一部分引用计数保存到 refcnts 中去，
      uintptr_t has_sidetable_rc  : 1;                                       \
      // 保存该对象的引用计数 -1 的值（未溢出之前，溢出后存放 RC_HALF）
      uintptr_t extra_rc          : 19 // 最大保存 2^19 - 1，觉得这个值很大呀, mac 下是 2^8 - 1 = 255
#   define RC_ONE   (1ULL<<45)
#   define RC_HALF  (1ULL<<18)
```

***

## 58. ISA() 函数返回的是 objc_object 所属的类地址。
&emsp;三种情况，一种是 isa 的位域（indexcls）中保存的是类对象在全局类表中的索引。一种是 isa 就是一个类指针。一种是 isa 的位域（shiftcls）中保存的是类对象的地址。 
```c++
// ISA() assumes this is NOT a tagged pointer object
// 假定不是 tagged pointer 对象时调用该函数
inline Class 
objc_object::ISA() 
{
    // 如果是 tagged pointer 则直接执行断言
    ASSERT(!isTaggedPointer()); 
#if SUPPORT_INDEXED_ISA
    // 支持在 isa 中保存类的索引的情况下
    
    if (isa.nonpointer) {
        uintptr_t slot = isa.indexcls;
        
        // 根据索引返回 class table 中的 Class
        return classForIndex((unsigned)slot);
    }
    
    // 如果是非优化指针直接返回 isa 中的 bits，由于 isa 是 union 所以 (Class)isa.bits 和 (Class)isa.cls 的值是一样的。
    return (Class)isa.bits;
#else
    // 从 shiftcls 位域取得 Class 指针，这个是我们平时用到的最多的，我们日常使用的实例对象获取所属的类都是通过这种方式。
    return (Class)(isa.bits & ISA_MASK);
#endif
}
```



## 🎉🎉🎉 未完待续...
