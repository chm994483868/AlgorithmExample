# iOS 2021 面试前的准备（总结各知识点方便面试前快速复习使用）（七）

## 55. 类声明中的成员变量的顺序和实际的成员变量的顺序。
&emsp;在面向对象（`oop`）的编程语言中，每一个对象都是某个类的实例。在 `Objective-C` 中，所有对象的本质都是一个 `objc_object` 结构体，且每个实例对象的第一个成员变量都是 `isa`，可从中取得该对象所属的类，每一个类描述了一系列它的实例对象的信息，包括对象占用内存大小、成员变量列表、该对象能执行的函数列表...等等。

&emsp;在一个类的实例对象的内存布局中，第一个成员变量是 `isa`，然后根据该对象所属类的继承体系依次对成员变量排序，排列顺序是: 根类的成员变量、父类的成员变量、最后才是自己的成员变量，且每个类定义中的成员变量（仅包含使用 `@property` 声明属性后由编译器生成的同名的 _成员变量）相互之间的顺序可能会与定义时的顺序不同，编译器会在内存对齐的原则下对类定义时的成员变量的顺序做出优化，保证内存占用最少。（还会涉及到 `.h` 中的成员变量和属性，`.m` 中 `extension` 中添加的成员变量和属性，它们之间的排序顺序）

&emsp;验证代码:
```objective-c
// SubObject 类定义
@interface SubObject : BaseObject {
    NSArray *cus_array;
}

@property (nonatomic, assign) int cus_int;
@property (nonatomic, assign) double cus_dou;
@property (nonatomic, assign) int cus_int2;
@property (nonatomic, copy) NSString *cus_string;

@end

// 添加断点，控制台打印
(lldb) p *sub
(SubObject) $2 = {
  BaseObject = {
    NSObject = {
      isa = SubObject
    }
    baseString = nil
    _baseArray = nil
  }
  cus_array = nil
  _cus_int = 0
  _cus_int2 = 0
  _cus_dou = 0
  _cus_string = nil
}
```
&emsp;可看到 `NSObject` 的 `isa` 在最前面，然后是 `BaseObject` 的成员变量，最后才是 `SubObject` 的成员变量，然后注意 `_cus_int2` 跑到了 `_cus_dou` 前面，而在类定义时 `cus_dou` 属性是在 `cus_int2` 属性前面的。（由于内存对齐时不用再为 `double` 补位，这样至少减少了 4 个字节的内存浪费）

***

## 56. 为什么不能动态的给类添加成员变量却可以添加方法？
&emsp;类的成员变量布局以及其实例对象大小在编译时就已确定，设想一下，如果 `Objective-C` 中允许给一个类动态添加成员变量，会带来一个问题：为基类动态增加成员变量会导致所有已创建出的子类实例都无法使用。我们所说的 “类的实例”（对象），指的是一块内存区域，里面存储了 `isa` 指针和所有的成员变量。所以假如允许动态修改类已固定的成员变量的布局，那么那些已经创建出的对象就不符合类的定义了，那就变成无效对象了。而方法的定义都是在类对象或元类对象中的，不管如何增删方法，都不会影响对象的内存布局，已经创建出的对象仍然可以正常使用。

***

## 57. ISA_BITFIELD 中的 64 位分别都代表什么。
```c++
#   define ISA_BITFIELD                                                      \
      // 表示 isa 中只是存放的 Class cls 指针还是包含更多信息的 bits
      uintptr_t nonpointer        : 1;                                       \
      // 标记该对象是否有关联对象，如果没有的话对象能更快的销毁，
      // 如果有的话销毁前会调用 _object_remove_assocations 函数根据关联策略循环释放每个关联对象
      uintptr_t has_assoc         : 1;                                       \
      // 标记该对象所属类是否有自定义的 C++ 析构函数，如果没有的话对象能更快销毁，
      // 如果有的话对象销毁前会调用 object_cxxDestruct 函数去执行该类的析构函数
      uintptr_t has_cxx_dtor      : 1;                                       \
      // isa & ISA_MASK 得出该实例对象所属的的类的地址
      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \
      // 用于调试器判断当前对象是真的对象还是没有初始化的空间
      uintptr_t magic             : 6;                                       \
      // 标记该对象是否有弱引用，如果没有的话对象能更快销毁，
      // 如果有的话对象销毁前会调用 weak_clear_no_lock 函数把该对象的弱引用置为 nil，
      // 并调用 weak_entry_remove 把对象的 entry 从 weak_table 中移除
      uintptr_t weakly_referenced : 1;                                       \
      // 标记该对象是否正在执行销毁
      uintptr_t deallocating      : 1;                                       \
      // 标记 refcnts 中是否也有保存实例对象的引用计数，当 extra_rc 溢出时会把一部分引用计数保存到 refcnts 中去，
      uintptr_t has_sidetable_rc  : 1;                                       \
      // 保存该对象的引用计数 -1 的值（未溢出之前，溢出后存放 RC_HALF）
      uintptr_t extra_rc          : 19 // 最大保存 2^19 - 1，觉得这个值很大呀, mac 下是 2^8 - 1 = 255
#   define RC_ONE   (1ULL<<45)
#   define RC_HALF  (1ULL<<18)
```

***

## 58. ISA() 函数返回的是 objc_object 所属的类地址。
&emsp;三种情况，一种是 isa 的位域（indexcls）中保存的是类对象在全局类表中的索引。一种是 isa 就是一个类指针。一种是 isa 的位域（shiftcls）中保存的是类对象的地址。 
```c++
// ISA() assumes this is NOT a tagged pointer object
// 假定不是 tagged pointer 对象时调用该函数
inline Class 
objc_object::ISA() 
{
    // 如果是 tagged pointer 则直接执行断言
    ASSERT(!isTaggedPointer()); 
#if SUPPORT_INDEXED_ISA
    // 支持在 isa 中保存类的索引的情况下
    
    if (isa.nonpointer) {
        uintptr_t slot = isa.indexcls;
        
        // 根据索引返回 class table 中的 Class
        return classForIndex((unsigned)slot);
    }
    
    // 如果是非优化指针直接返回 isa 中的 bits，由于 isa 是 union 所以 (Class)isa.bits 和 (Class)isa.cls 的值是一样的。
    return (Class)isa.bits;
#else
    // 从 shiftcls 位域取得 Class 指针，这个是我们平时用到的最多的，我们日常使用的实例对象获取所属的类都是通过这种方式。
    return (Class)(isa.bits & ISA_MASK);
#endif
}
```

***

## 59. isWeaklyReferenced / sidetable_isWeaklyReferenced
&emsp;判断对象是否存在弱引用。
```c++
inline bool
objc_object::isWeaklyReferenced()
{
    // 如果是 Tagged Pointer 执行断言
    ASSERT(!isTaggedPointer());
    
    // 如果是非指针则返回 weakly_referenced 标记位
    if (isa.nonpointer) return isa.weakly_referenced;
    
    // 其他情况调用 sidetable_isWeaklyReferenced
    //（当 isa 是 objc_class 指针时，对象的弱引用标识位在 SideTable 的 refcnts 中）
    else return sidetable_isWeaklyReferenced();
}
```

&emsp;`isa` 是原始类指针的对象的是否有弱引用的标识在 `refcnts` 中。
```c++
bool 
objc_object::sidetable_isWeaklyReferenced()
{
    bool result = false;
    
    // 取得对象所处的 SideTable
    SideTable& table = SideTables()[this];
    // 加锁
    table.lock();
    
    RefcountMap::iterator it = table.refcnts.find(this);
    // 判断当前对象是否存在 SideTable 的 refcnts 中
    if (it != table.refcnts.end()) {
        // 如果存在 
        // it->second 是引用计数 与 SIDE_TABLE_WEAKLY_REFERENCED 进行与操作
        // 引用计数值的第 1 位是弱引用的标识位哦
        result = it->second & SIDE_TABLE_WEAKLY_REFERENCED;
    }
    
    // 解锁
    table.unlock();

    return result;
}
```

***

## 60. Tagged Pointer 解读。
&emsp;2013 年 9 月，苹果首次在 iOS 平台推出了搭载 64 位架构处理器的 iPhone（iPhone 5s），为了节省内存和提高运行效率，提出了 Tagged Pointer 概念。

&emsp;Tagged Pointer 是苹果为了在 64 位架构的处理器下节省内存占用和提高运行效率而提出的概念。它的本质是把一些占用内存较小的对象的数据直接放在指针的内存空间内，然后把这个指针直接作为对象使用，直接省去了为对象在堆区开辟空间的过程。

&emsp;这里引出了一个疑问，“对象的内存都是位于堆区吗？” 是的。下面是我自己的推测：默认这里说的对象都是 NSObject 的子类，当深入看 + (id)alloc 函数时，可看到最后面开辟空间都是使用的 malloc（calloc 函数内部是调用 malloc 后再调用 bzero 置 0）函数，而 malloc 是 C 的运行库函数，向它申请的内存都是 C 运行库管理，采用堆的内存管理方式。该函数实际上会向操作系统申请内存，然后分配给请求者，同时其内部维护有它申请的内存的分配情况，以便管理其拥有的内存。

&emsp;指针变量的长度与地址总线有关。从 32 位系统架构切换到 64 位系统架构后，指针变量的长度也会由 32 位增加到 64 位。如果不考虑其它因素，64 位指针可表示的地址长度可达到 2^64 字节即 2^34 TB，以目前的设备的内存来看，使用 8 个字节存储一个地址数据，其实有很多位都是空余的，而 Tagged Pointer 正是为了把这些空余的空间利用起来。（例如，在 iPhone 真机下，在堆区创建一个 NSObject 对象，打印的它的地址，看到只占用了 36 位，剩下 28 位都是零。） 


## 🎉🎉🎉 未完待续...
