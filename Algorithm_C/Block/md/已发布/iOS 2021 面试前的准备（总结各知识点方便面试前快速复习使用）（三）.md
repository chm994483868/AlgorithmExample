# iOS 2021 面试前的准备（总结各知识点方便面试前快速复习使用）（三）

> &emsp;博主前期通读了 Apple 的五份源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)、[libdispatch-1173.40.5](https://opensource.apple.com/tarballs/libdispatch/)、[CF-1151.16](https://opensource.apple.com/tarballs/CF/)、[libmalloc-283.100.6](https://opensource.apple.com/tarballs/libmalloc/)、[libclosure-74](https://opensource.apple.com/source/libclosure/) 基本对 iOS 的大部分底层原理都有了一个基础的认知，然后算法部分的话是专注刷了两遍 《剑指 Offer》（在 IDE 里可以完成默写，完全手写的话可能还需要一些练习）。那么既然是面试肯定免不了要刷题，题目的话就从网络搜集各位大佬面试时的题目以及本人面试时被问到的题目，然后试着从自己的理解上给题目作出解答，如有错误的地方还望大家进行指正。   

## 21. dispatch_semaphore 执行原理。
&emsp;dispatch_semaphore 是 GCD 中提供的一个很常用的操作，通常用于保证资源的多线程安全性和控制任务的并发数量。其本质实际上是基于 mach 内核的信号量接口来实现的。

&emsp;`dispatch_semaphore_t` 是指向 `dispatch_semaphore_s` 结构体的指针。首先看一下基础的数据结构。
```c++
struct dispatch_queue_s;

DISPATCH_CLASS_DECL(semaphore, OBJECT);
struct dispatch_semaphore_s {
    DISPATCH_OBJECT_HEADER(semaphore);
    
    // 可看到上半部分的宏定义和其它的 GCD 类是相同的，毕竟大家都是继承自 dispatch_object_s，重点是下面两个新的成员变量，
    // dsema_value 和 dsema_orig 是信号量执行任务的关键，执行一次 dispatch_semaphore_wait 操作，dsema_value 的值就做一次减操作。
    
    long volatile dsema_value;
    long dsema_orig;
    _dispatch_sema4_t dsema_sema;
};
```
&emsp;`dispatch_semaphore_s` 结构体中：`dsema_orig` 是信号量的初始值，`dsema_value` 是信号量的当前值，信号量的相关 API 正是通过操作 `dsema_value` 来实现其功能的。

&emsp;`dispatch_semaphore_create` 用初始值（`long value`）创建新的计数信号量。当两个线程需要协调特定事件的完成时，将值传递为零非常有用。传递大于零的值对于管理有限的资源池非常有用，该资源池的大小等于该值（例如我们有多个文件要从服务器下载下来，然后用 dispatch_semaphore 限制只能并发五条线程（`dispatch_semaphore_create(5)`）进行下载）。

&emsp;参数 `value`：信号量的起始值，传递小于零的值将导致返回 `NULL`。返回值 `result`：新创建的信号量，失败时为 `NULL`。

&emsp;`dispatch_semaphore_wait` 等待（减少）信号量。
```c++
long
dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
    // 原子操作 dsema 的成员变量 dsema_value 的值减 1
    long value = os_atomic_dec2o(dsema, dsema_value, acquire);
    
    // 如果减 1 后仍然大于等于 0，则直接 return 
    if (likely(value >= 0)) {
        return 0;
    }
    
    // 如果小于 0，则调用 _dispatch_semaphore_wait_slow 函数进行阻塞等待
    return _dispatch_semaphore_wait_slow(dsema, timeout);
}
```
&emsp;减少计数信号量，如果结果值小于零，此函数将等待信号出现，然后返回。（可以使总信号量减 1，信号总量小于 0 时就会一直等待（阻塞所在线程），否则就可以正常执行。）`dsema`：信号量，在此参数中传递 `NULL` 的结果是未定义的。`timeout`：何时超时（dispatch_time），为方便起见，有 `DISPATCH_TIME_NOW` 和 `DISPATCH_TIME_FOREVER` 常量。函数返回值 `result`，成功返回零，如果发生超时则返回非零（`_DSEMA4_TIMEOUT`）。

&emsp;当 `timeout` 是 `DISPATCH_TIME_FOREVER` 时，do while 循环一直等下去，直到 `sema` 的值被修改为不等于 `KERN_ABORTED`。
```c++
void
_dispatch_sema4_wait(_dispatch_sema4_t *sema)
{
    kern_return_t kr;
    do {
        kr = semaphore_wait(*sema);
    } while (kr == KERN_ABORTED);
    
    DISPATCH_SEMAPHORE_VERIFY_KR(kr);
}
```
&emsp;其中调用了 mach 内核的信号量接口 `semaphore_wait` 和 `semaphore_timedwait` 进行 wait 操作。所以，GCD 的信号量实际上是基于 mach 内核的信号量接口来实现。`semaphore_timedwait` 函数即可以指定超时时间。

&emsp;`dispatch_semaphore_signal` 发信号（增加）信号量。如果先前的值小于零，则此函数在返回之前唤醒等待的线程。如果线程被唤醒，此函数将返回非零值。否则，返回零。
```c++
long
dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
    // 原子操作 dsema 的成员变量 dsema_value 的值加 1
    long value = os_atomic_inc2o(dsema, dsema_value, release);
    
    if (likely(value > 0)) {
        // 如果 value 大于 0 表示目前没有线程需要唤醒，直接 return 0
        return 0;
    }
    
    // 如果过度释放，导致 value 的值一直增加到 LONG_MIN（溢出），则 crash 
    if (unlikely(value == LONG_MIN)) {
        DISPATCH_CLIENT_CRASH(value, "Unbalanced call to dispatch_semaphore_signal()");
    }
    
    // value 小于等于 0 时，表示目前有线程需要唤醒
    return _dispatch_semaphore_signal_slow(dsema);
}
```

&emsp;`_dispatch_semaphore_signal_slow` 内部调用 `_dispatch_sema4_signal(&dsema->dsema_sema, 1)` 唤醒一条线程。
```c++
DISPATCH_NOINLINE
long _dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema) {
    _dispatch_sema4_create(&dsema->dsema_sema, _DSEMA4_POLICY_FIFO);
    
    // count 传 1，唤醒一条线程
    _dispatch_sema4_signal(&dsema->dsema_sema, 1);
    
    return 1;
}
```
&emsp;`semaphore_signal` 能够唤醒一个在 `semaphore_wait` 中等待的线程。如果有多个等待线程，则根据线程优先级来唤醒。
```c++
void
_dispatch_sema4_signal(_dispatch_sema4_t *sema, long count)
{
    do {
        // semaphore_signal 唤醒线程
        kern_return_t kr = semaphore_signal(*sema);
        DISPATCH_SEMAPHORE_VERIFY_KR(kr);
    } while (--count);
}
```

***

## 22. dispatch_group 执行原理。
&emsp;dispatch_group 可以将一组 GCD 任务关联到一起，可以监听这一组所有任务的执行情况，当所有任务异步执行完毕后我们可以得到一个或多个回调通知（使用 `dispatch_group_notify` 添加几个就能执行几个回调通知）。（dispatch_group 不持有与它相关的任务 block，但是会通过链表的形式持有 `dispatch_group_notify` 函数添加的回调通知 block）

&emsp;`dispatch_group_s` 定义和 `dispatch_semaphore_s` 定义都是放在 semaphore_internal.h 文件中，而且该文件中仅包含它俩的内容，其实文件这样布局也是有用意的，因为它俩的内部实现有一些相似性，dispatch_group 在内部也会维护一个值，当调用 `dispatch_group_enter` 函数进行进组操作时（`dg_bits` - `0x0000000000000004ULL`），当调用 `dispatch_group_leave` 函数进行出组操作时（`dg_state` + `0x0000000000000004ULL`）时对该值进行操作（这里可以把 `dg_bits` 和 `dg_state` 理解为一个值），当该值达到临界值 0 时会做一些后续操作（`_dispatch_group_wake` 唤醒异步执行 `dispatch_group_notify` 函数添加的所有回调通知），且在使用过程中一定要谨记进组（enter）和出组（leave）必须保持平衡。

&emsp;假设与 dispatch_group 关联的 GCD 任务是一个 block，dispatch_group 并不持有此 block，甚至 dispatch_group 与此 block 没有任何关系，dispatch_group 内部的那个值只是与 enter/leave 操作有关，GCD 任务只是借用了此值，例如在创建多个 GCD 异步任务之前调用多次 enter 操作，然后在每个 GCD 任务结束时调用 leave 操作，当这多个 GCD 异步任务都执行完毕，那么如果 dispatch_group 添加了回调通知，此时自会收到回调通知。即使我们使用 dispatch_group_async 创建多个 GCD 异步任务 block， 这些 GCD 任务 block 其实与 dispatch_group 也没有任何直接的关系。

&emsp;那么与这些 GCD 异步任务相比的话，我们使用 `dispatch_group_notify` 函数添加的多个回调通知的 block 则是被 dispatch_group 所完全拥有的，这些回调通知 block 会链接成一个链表，而 dispatch_group 实例则直接拥有此链表的头节点和尾节点。

&emsp;`dispatch_group_t` 是指向 `dispatch_group_s` 结构体的指针，`dispatch_group_s` 结构体的定义如下。
```c++
DISPATCH_CLASS_DECL(group, OBJECT);
struct dispatch_group_s {
    DISPATCH_OBJECT_HEADER(group);
    // 可看到上半部分和其它 GCD 对象都是相同的，毕竟大家都是继承自 dispatch_object_s，重点是下面的新内容 
    
    union { 
        uint64_t volatile dg_state;  // leave 时加 DISPATCH_GROUP_VALUE_INTERVAL
        struct { 
            uint32_t dg_bits; // enter 时减 DISPATCH_GROUP_VALUE_INTERVAL
            
            // 主要用于 dispatch_group_wait 函数被调用后，
            // 当 dispath_group 处于 wait 状态时，结束等待的条件有两条：
            // 1): 当 dispatch_group 关联的 block 都执行完毕后，wait 状态结束
            // 2): 当到达了指定的等待时间后，即使关联的 block 没有执行完成，也结束 wait 状态 
            
            // 而当 dg_gen 不为 0 时，说明 dg_state 发生了进位，可表示 dispatch_group 关联的 block 都执行完毕了，
            // 如果 dispatch_group 此时处于 wait 状态的话就可以结束了，此时正对应上面结束 wait 状态的条件 1 中。
            uint32_t dg_gen;
        };
    } __attribute__((aligned(8)));
    
    // 下面两个成员变量比较特殊，它们分别是一个链表的头节点指针和尾节点指针
    // 调用 dispatch_group_notify 函数可添加当 dispatch_group 关联的 block 异步执行完成后的回调通知，
    // 多次调用 dispatch_group_notify 函数可添加多个回调事件（我们日常开发一般就用了一个回调事件，可能会忽略这个细节），
    // 而这些多个回调事件则会构成一个 dispatch_continuation_s 作为节点的链表，当 dispatch_group 中关联的 block 全部执行完成后，
    // 此链表中的 dispatch_continuation_s 都会得到异步执行。
    //（注意是异步，具体在哪个队列则根据 dispatch_group_notify 函数的入参决定，以及执行的优先级则根据队列的优先级决定）。
    
    struct dispatch_continuation_s *volatile dg_notify_head; // dispatch_continuation_s 链表的头部节点
    struct dispatch_continuation_s *volatile dg_notify_tail; // dispatch_continuation_s 链表的尾部节点
};
```
&emsp;`dg_bits` 和 `dg_state` 是联合体共享同一块内存空间的不同名的成员变量，进组和出组时减少和增加 `DISPATCH_GROUP_VALUE_INTERVAL` 操作的其实是同一个值，再详细一点的话是联合体共占用 64 bit 空间，其中 uint64_t 类型的 dg_state 可占完整 64 bit，然后 uint32_t 类型的 `dg_bits` 和  uint32_t 类型的 `dg_gen` 组成结构体共占用这 64 bit，其中 `dg_bits` 在 低 32 bit，`dg_gen` 在高 32 bit。





















## 什么是 ARC 以及 ARC 的工作原理，ARC 下会存在内存泄漏吗？

***

## UIView 与 CALayer  CoreAnimation 

***
