# iOS 2021 面试前的准备（总结各知识点方便面试前快速复习使用）（三）

> &emsp;博主前期通读了 Apple 的五份源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)、[libdispatch-1173.40.5](https://opensource.apple.com/tarballs/libdispatch/)、[CF-1151.16](https://opensource.apple.com/tarballs/CF/)、[libmalloc-283.100.6](https://opensource.apple.com/tarballs/libmalloc/)、[libclosure-74](https://opensource.apple.com/source/libclosure/) 基本对 iOS 的大部分底层原理都有了一个基础的认知，然后算法部分的话是专注刷了两遍 《剑指 Offer》（在 IDE 里可以完成默写，完全手写的话可能还需要一些练习）。那么既然是面试肯定免不了要刷题，题目的话就从网络搜集各位大佬面试时的题目以及本人面试时被问到的题目，然后试着从自己的理解上给题目作出解答，如有错误的地方还望大家进行指正。   

## 21. dispatch_semaphore 执行原理。
&emsp;dispatch_semaphore 是 GCD 中提供的一个很常用的操作，通常用于保证资源的多线程安全性和控制任务的并发数量。其本质实际上是基于 mach 内核的信号量接口来实现的。

&emsp;`dispatch_semaphore_t` 是指向 `dispatch_semaphore_s` 结构体的指针。首先看一下基础的数据结构。
```c++
struct dispatch_queue_s;

DISPATCH_CLASS_DECL(semaphore, OBJECT);
struct dispatch_semaphore_s {
    DISPATCH_OBJECT_HEADER(semaphore);
    
    // 可看到上半部分的宏定义和其它的 GCD 类是相同的，毕竟大家都是继承自 dispatch_object_s，重点是下面两个新的成员变量，
    // dsema_value 和 dsema_orig 是信号量执行任务的关键，执行一次 dispatch_semaphore_wait 操作，dsema_value 的值就做一次减操作。
    
    long volatile dsema_value;
    long dsema_orig;
    _dispatch_sema4_t dsema_sema;
};
```
&emsp;`dispatch_semaphore_s` 结构体中：`dsema_orig` 是信号量的初始值，`dsema_value` 是信号量的当前值，信号量的相关 API 正是通过操作 `dsema_value` 来实现其功能的。

&emsp;`dispatch_semaphore_create` 用初始值（`long value`）创建新的计数信号量。当两个线程需要协调特定事件的完成时，将值传递为零非常有用。传递大于零的值对于管理有限的资源池非常有用，该资源池的大小等于该值（例如我们有多个文件要从服务器下载下来，然后用 dispatch_semaphore 限制只能并发五条线程（`dispatch_semaphore_create(5)`）进行下载）。

&emsp;参数 `value`：信号量的起始值，传递小于零的值将导致返回 `NULL`。返回值 `result`：新创建的信号量，失败时为 `NULL`。

&emsp;`dispatch_semaphore_wait` 等待（减少）信号量。
```c++
long
dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
    // 原子操作 dsema 的成员变量 dsema_value 的值减 1
    long value = os_atomic_dec2o(dsema, dsema_value, acquire);
    
    // 如果减 1 后仍然大于等于 0，则直接 return 
    if (likely(value >= 0)) {
        return 0;
    }
    
    // 如果小于 0，则调用 _dispatch_semaphore_wait_slow 函数进行阻塞等待
    return _dispatch_semaphore_wait_slow(dsema, timeout);
}
```
&emsp;减少计数信号量，如果结果值小于零，此函数将等待信号出现，然后返回。（可以使总信号量减 1，信号总量小于 0 时就会一直等待（阻塞所在线程），否则就可以正常执行。）`dsema`：信号量，在此参数中传递 `NULL` 的结果是未定义的。`timeout`：何时超时（dispatch_time），为方便起见，有 `DISPATCH_TIME_NOW` 和 `DISPATCH_TIME_FOREVER` 常量。函数返回值 `result`，成功返回零，如果发生超时则返回非零（`_DSEMA4_TIMEOUT`）。

&emsp;当 `timeout` 是 `DISPATCH_TIME_FOREVER` 时，do while 循环一直等下去，直到 `sema` 的值被修改为不等于 `KERN_ABORTED`。
```c++
void
_dispatch_sema4_wait(_dispatch_sema4_t *sema)
{
    kern_return_t kr;
    do {
        kr = semaphore_wait(*sema);
    } while (kr == KERN_ABORTED);
    
    DISPATCH_SEMAPHORE_VERIFY_KR(kr);
}
```
&emsp;其中调用了 mach 内核的信号量接口 `semaphore_wait` 和 `semaphore_timedwait` 进行 wait 操作。所以，GCD 的信号量实际上是基于 mach 内核的信号量接口来实现。`semaphore_timedwait` 函数即可以指定超时时间。

&emsp;`dispatch_semaphore_signal` 发信号（增加）信号量。如果先前的值小于零，则此函数在返回之前唤醒等待的线程。如果线程被唤醒，此函数将返回非零值。否则，返回零。
```c++
long
dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
    // 原子操作 dsema 的成员变量 dsema_value 的值加 1
    long value = os_atomic_inc2o(dsema, dsema_value, release);
    
    if (likely(value > 0)) {
        // 如果 value 大于 0 表示目前没有线程需要唤醒，直接 return 0
        return 0;
    }
    
    // 如果过度释放，导致 value 的值一直增加到 LONG_MIN（溢出），则 crash 
    if (unlikely(value == LONG_MIN)) {
        DISPATCH_CLIENT_CRASH(value, "Unbalanced call to dispatch_semaphore_signal()");
    }
    
    // value 小于等于 0 时，表示目前有线程需要唤醒
    return _dispatch_semaphore_signal_slow(dsema);
}
```

&emsp;`_dispatch_semaphore_signal_slow` 内部调用 `_dispatch_sema4_signal(&dsema->dsema_sema, 1)` 唤醒一条线程。
```c++
DISPATCH_NOINLINE
long _dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema) {
    _dispatch_sema4_create(&dsema->dsema_sema, _DSEMA4_POLICY_FIFO);
    
    // count 传 1，唤醒一条线程
    _dispatch_sema4_signal(&dsema->dsema_sema, 1);
    
    return 1;
}
```
&emsp;`semaphore_signal` 能够唤醒一个在 `semaphore_wait` 中等待的线程。如果有多个等待线程，则根据线程优先级来唤醒。
```c++
void
_dispatch_sema4_signal(_dispatch_sema4_t *sema, long count)
{
    do {
        // semaphore_signal 唤醒线程
        kern_return_t kr = semaphore_signal(*sema);
        DISPATCH_SEMAPHORE_VERIFY_KR(kr);
    } while (--count);
}
```

***

## 22. dispatch_group 执行原理。
&emsp;dispatch_group 可以将一组 GCD 任务关联到一起，可以监听这一组所有任务的执行情况，当所有任务异步执行完毕后我们可以得到一个或多个回调通知（使用 `dispatch_group_notify` 添加几个就能执行几个回调通知）。














## 什么是 ARC 以及 ARC 的工作原理，ARC 下会存在内存泄漏吗？

***

## UIView 与 CALayer  CoreAnimation 

***
