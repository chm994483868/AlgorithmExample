# iOS 2021 面试前的准备（从网络搜集各种面试题并解答）

> &emsp;博主前期通读了 Apple 的五份源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)、[libdispatch-1173.40.5](https://opensource.apple.com/tarballs/libdispatch/)、[CF-1151.16](https://opensource.apple.com/tarballs/CF/)、[libmalloc-283.100.6](https://opensource.apple.com/tarballs/libmalloc/)、[libclosure-74](https://opensource.apple.com/source/libclosure/) 基本对 iOS 的大部分底层原理都有了一个基础的认知，然后算法部分的话是专注刷了两遍 《剑指 Offer》（在 IDE 里可以完成默写，完全手写的话可能还需要一些练习）。那么既然是面试肯定免不了要刷题，题目的话就从网络搜集各位大佬面试时的题目，然后试着从自己的理解上给题目作出解答，如有错误的地方还望大家进行指正。   

## 1. KVC 的工作原理。
&emsp;[iOS《Key-Value Coding Programming Guide》官方文档](https://juejin.cn/post/6915290445069156366) 和 [iOS《Key-Value Coding Programming Guide》官方文档](https://juejin.cn/post/6915290445069156366) 这两篇是 KVC 和 KVO 官方文档的翻译，如果需要的话可以进行详细阅读，下面对它们的原理进行简要总结。

&emsp;Key-Value Coding（键值编码）是由 NSKeyValueCoding 非正式协议启用的一种机制，对象采用这种机制来提供对其属性/成员变量的**间接访问**。当一个对象符合键值编码时，它的所有属性/成员变量可以通过一个简洁、统一的消息传递接口（`setValue:forKey:`）通过字符串参数寻址。这种**间接访问机制补充了实例变量及其相关访问器方法（getter 方法）提供的直接访问**。

&emsp;KVC 在代码实现层面则是在 Foundation 框架下有一个 NSKeyValueCoding.h 文件，其内部定义了多组分类接口，其中包括：@interface NSObject(NSKeyValueCoding)、@interface NSArray<ObjectType>(NSKeyValueCoding)、@interface NSDictionary<KeyType, ObjectType>(NSKeyValueCoding)、@interface NSMutableDictionary<KeyType, ObjectType>(NSKeyValueCoding)、@interface NSOrderedSet<ObjectType>(NSKeyValueCoding)、@interface NSSet<ObjectType>(NSKeyValueCoding)，其中 NSObject 基类已经实现了 NSKeyValueCoding 机制的所有接口，所以我们自己创建的 NSObject 子类都是支持 KVC 的，然后 NSArray、NSDictionary、NSMutableDictionary、NSOrderedSet、NSSet 这些子类则是对 `setValue:forKey:` 和 `valueForKey:` 函数进行重载。例如当对一个 NSArray 对象调用 `setValue:forKey:` 函数时，它内部是对数组中的每个元素调用 `setValue:forKey:` 函数。当对一个 NSArray 对象调用 `valueForKey:` 函数时，它返回一个数组，其中包含在数组的每个元素上调用 `valueForKey:` 的结果。返回的数组将包含 `NSNull` 元素，指代的是数组中某些元素调用 `valueForKey:` 函数返回 nil 的情况。

&emsp;集合运算符（@avg、@count、@max、@min、@sum）数组运算符（@distinctUnionOfObjects、@unionOfObjects、）嵌套运算符（@distinctUnionOfArrays、@unionOfArrays、@distinctUnionOfSets）。

&emsp;非对象类型的属性的包装和解包，如 int/float 包装成 NSNumber，struct（NSPoint、NSRange、NSRect、NSSize） 包装成 NSValue。

&emsp;在给定键参数作为输入的情况下，`valueForKey:` 的默认实现执行以下过程。（在接收 `valueForKey:` 调用的类对象内部进行操作）

1. 在实例中搜索第一个名为 `get<Key>`、`<key>`、`is<Key>` 或 `\_<key>` 的访问器方法。如果找到了，则调用它并继续执行步骤 5 并返回结果。否则继续下一步。（如果想简单描述的话可以把步骤 2 和 3 省略）

2. 如果找不到简单的访问器方法，在实例中搜索名称与 `countOf<Key>`、`objectIn<Key>AtIndex:`（对应于 NSArray 类定义的原始方法） 和 `<key>AtIndexes:`（对应于 NSArray 的 `objectsAtIndexes:` 方法）模式匹配的方法。
  如果找到其中的第一个以及其他两个中的至少一个，则创建一个响应所有 NSArray 方法的集合代理对象（collection proxy object），并返回该对象。否则，请继续执行步骤 3。
  代理对象随后将接收到的任何 NSArray 消息转换为 `countOf<Key>`、`objectIn<Key>AtIndex:` 和 `<Key>AtIndexes:` 消息的组合，并将其转换为创建它的键值编码兼容对象。如果原始对象还实现了一个名为 `get<Key>:range:` 之类的可选方法，则代理对象也将在适当时使用该方法。实际上，代理对象与键值编码兼容的对象一起工作，允许底层属性的行为就像 NSArray 一样，即使它不是。
  
3. 如果找不到简单的访问器方法或数组访问方法组，请查找名为 `countOf<Key>`、`enumeratorOf<Key>` 和 `memberOf<Key>` 的三重方法。（对应于 NSSet 类定义的原始方法）
  如果找到所有三个方法，请创建一个响应所有 NSSet 方法的集合代理对象，并返回该对象。否则，继续执行步骤 4。
  代理对象随后将接收到的任何 NSSet 消息转换为 `countOf<Key>`、`enumeratorOf<Key>` 和 `memberOf<Key>` 消息的某种组合，以创建它的对象。实际上，代理对象与键值编码兼容对象一起工作，使得基础属性的行为就像 NSSet 一样，即使它不是 NSSet。
  
4. 如果找不到简单的访问器方法或集合访问方法组，并且如果 receiver 的类方法 `accessInstanceVariablesDirectly` 返回 YES，则按该顺序搜索名为 `\_<key>`、`\_is<Key>`、`<key>` 或 `is<Key>` 的实例变量。如果找到，则直接获取实例变量的值并继续执行步骤 5。否则，继续进行步骤 6。

5. 如果检索到的属性值是对象指针，则只需返回结果。
  如果该值是 NSNumber 支持的标量类型，则将其存储在 NSNumber 实例中并返回它。
  如果结果是 NSNumber 不支持的标量类型，则转换为 NSValue 对象并返回该对象。
  
6. 如果所有方法均失败，则调用 `valueForUndefinedKey:`。默认情况下，这会引发一个 NSUndefinedKeyException 异常，但是 NSObject 的子类可以提供特定于键的行为（子类重写 `valueForUndefinedKey:` 函数，那进一步我们自行添加一个 NSObject 分类重写 `valueForUndefinedKey:` 方法呢？）。

&emsp;`setValue:forKey:` 的默认实现，给定 key 和 value 参数作为输入，尝试将名为 key 的属性设置为 value，使用以下过程在接收到调用的对象内部：

1. 按此顺序查找名为 `set<Key>:` 或 `\_set<Key>` 的第一个访问器。如果找到了，则使用 value（或根据需要解包 value 的值）调用它并完成。

2. 如果未找到简单的访问器，并且类方法 `accessInstanceVariablesDirectly` 返回 YES，按该顺序查找名称类似于 `\_<key>`、`\_is<Key>`、`<key>` 或 `is<Key>` 的实例变量。如果找到，则直接使用 value（或根据需要解包 value 的值）设置实例变量并完成操作。

3. 在找不到访问器或实例变量时，调用 `setValue:forUndefinedKey:`。这在默认情况下会引发 NSUndefinedKeyException 异常，但 NSObject 的子类可能会提供键特定的行为。（由子类重写 `setValue:forUndefinedKey:`）

> &emsp;NOTE: 当你使用非对象属性的 nil 值调用其中一个键值编码协议 setter 时，setter 没有明显的常规操作过程可采取。因此，它向接收 setter 调用的对象发送 `setNilValueForKey:` 消息。此方法的默认实现会引发 NSInvalidArgumentException 异常，但子类可能会重写此行为，如处理非对象值中所述，例如设置标记值或提供有意义的默认值。

&emsp;键值编码是高效的，尤其是当你依靠默认实现来完成大部分工作时，但是它确实添加了一个间接级别，该级别比直接的方法调用稍慢。只有当你可以从它提供的灵活性中获益或者允许你的对象参与依赖于它的 Cocoa 技术时，才使用键值编码。

***

## 2. KVO 的工作原理。（追加 KVO 动态生成的新类重写了 Setter 函数后，原始 Setter 函数会怎么样？对对象的某个属性添加观察者后那对象的 isa 指向和 class 函数会发生什么变化？移除观察者后呢？）
&emsp;Key-Value Observing（键值观察）是一种机制，它允许将其他对象的指定属性的更改通知给对象。

&emsp;自动键值观察是使用 isa 交换技术实现的。

&emsp;顾名思义，isa 指针指向维护调度表的对象类。这个调度表本质上包含指向类实现的方法的指针以及其他数据。

&emsp;当一个观察者为一个对象的属性注册时，被观察者对象的 isa 指针被修改，指向一个中间类而不是原始类（NSKVONotifying_XXX）。因此，isa 指针的值不一定反映实例的实际类。

&emsp;决不能依赖 isa 指针来确定类的实例对象身份。相反，应该使用 class 方法来确定对象实例的类。

> &emsp;KVO 是通过 isa-swizzling 实现的。基本的流程就是编译器自动为被观察者对象创造一个派生类（此派生类的父类是被观察者对象所属的类），并将被观察者对象的 isa  指向这个派生类。如果用户注册了对此目标对象的某一个属性的观察，那么此派生类会重写这个属性的 setter 方法，并在其中添加进行通知的代码。Objective-C 在发送消息的时候，会通过 isa 指针找到当前对象所属的类对象。而类对象中保存着当前对象可调用的实例方法，因此在向此对象发送消息时候，实际上是发送到了派生类对象的方法。由于编译器对派生类的方法进行了重写，并添加了通知代码，因此会向注册的观察者对象发送通知。注意派生类只重写注册了观察者的属性方法。

```c++
-(void)setValue:(id)obj {
    [self willChangeValueForKey:@"keyPath"];
    
    // 这里内部使用 super 调用，由于当前派生类的 super 正是指向原类，所以不影响原类中自己手动实现的 setter 函数调用（去 58 面试时遇到了这个问题） 
    [super setValue:obj];
    
    [self didChangeValueForKey:@"keyPath"];
}
```

&emsp;如下示例代码中定义的 Student 类，当对其 name 属性注册了观察者后，打印其 class 和 isa 如下：
```c++
@interface Student : NSObject
@property (nonatomic, copy) NSString *name;
@end

// 对 self.student 添加观察者后 class 函数返回的依然是 Student
NSLog(@"🤍🤍 %@", [self.student class]);

// object_getClass 方法返回 isa 指向却是 NSKVONotifying_Student
NSLog(@"🤍🤍 %@", object_getClass(self.student));

// 控制台打印:
🤍🤍 Student
🤍🤍 NSKVONotifying_Student
 
// 然后移除 self.student 的观察者后，object_getClass(self.student) 返回的则是 Student。
```

> &emsp;简而言之，苹果使用了一种 isa 交换的技术，当 student 被观察后，student 对象的 isa 指针被指向了一个新建的 Student 的子类 NSKVONotifying_Student，且这个子类重写了被观察值的 setter 方法和 class 方法，dealloc 和 \_isKVO 方法，然后使 student 对象的 isa 指针指向这个新建的类，然后事实上 student 变为了NSKVONotifying_Student 的实例对象，执行方法要从这个类的方法列表里找。dealloc 方法：观察者移除后使 class 变回去 Student（通过 isa 指向）, \_isKVO 方法判断被观察者自己是否同时也观察了其他对象。（同时苹果警告我们，通过 isa 获取类的类型是不可靠的，通过 class 方法才能得到正确的类）[用代码探讨 KVC/KVO 的实现原理](https://juejin.cn/post/6844903587898753037)

***

## 3. 什么是 ARC 以及 ARC 的工作原理，ARC 下会存在内存泄漏吗？
&emsp;

***

## 4. UIView 与 CALayer  CoreAnimation 





1. iOS 屏幕成像原理（离屏渲染 Off-screen Rendered）。
2. atomic、nonatomic、strong（retain）、weak（unsafe_unretained）、assign 属性修饰符的工作原理。（\_\_strong、\_\_weak、\_\_unsafe_unretained）
3. weak 底层实现原理。
  + DisguisedPtr<objc_object> DisguisedPtr<objc_object *> 伪装指针，把地址变为整数保存。
  + typedef DisguisedPtr<objc_object *> weak_referrer_t; weak 变量的地址，即一个指针的指针。
  + struct weak_entry_t 保存某个对象的所有 weak 变量地址的哈希表。
  + struct weak_table_t 保存对象和其 weak_entry_t 的哈希表。
  + struct SideTable 某个对象所处的 SideTable 表，有三个成员变量：spinlock_t slock、RefcountMap refcnts、weak_table_t weak_table。
  + static StripedMap<SideTable>& SideTables 保存 8/64 张 SideTable，获取某个对象所处的 SideTable：SideTable *table = &SideTables()[obj]。
  
  + 对 weak_entry_t 和 weak_table_t 的哈希数组进行操作。存放 weak 变量和移除 weak 变量、weak 变量置为 nil 等操作。
  
  + objc_loadWeakRetained、objc_loadWeak weak 变量读取。（objc_copyWeak、objc_moveWeak）
  
4. AssociatedObject 底层实现原理。class ObjcAssociation 用于保存关联策略和关联值。ObjectAssociationMap 是 key 是 const void *（用于标识某个关联值的 key），value 是 ObjcAssociation 的哈希表。AssociationsHashMap 是 key 是 DisguisedPtr<objc_object>，value 是 ObjectAssociationMap 的哈希表。AssociationsManager 是 key 是 DisguisedPtr<objc_object>，value 是 ObjectAssociationMap 的哈希表。
5. Category 底层实现原理。概念与数据结构：category_t。追加 attachLists、methodizeClass，先编译的先追加，旧函数向后移动，新函数从头开始追加，所以后编译的 category 会追加到列表的最前面去。+ load 函数执行。
6. TaggedPointer 知识点。





## 参考链接
**参考链接:🔗**
+ [NSCoding](https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSCoding/Description.html#//apple_ref/occ/intf/NSCoding)


1. 音视频处理方向。
2. 编译原理，阅读《程序员的自我修养》。
3. 复习、算法、计算机网络。

## 58同城面试题
1. 简单的自我介绍。
2. 介绍 http 和 https。
3. TCP 和 UDP 的区别。
4. KVC 和 KVO 的原理以及追问 KVO 重写 Setter 函数后原始 Setter 函数会怎么样。
5. VC 的生命周期。
6. viewDidLoad 函数中创建的一个局部 OC 变量什么时候销毁。
7. 怎么区分堆区和栈区。
8. block 的分类。
9. runloop 的工作原理。
10. runtime 的消息发送流程。runtime 的常用场景。
11. UIView 和 CALayer 的关系。
12. CoreAnimation 实现动画。
13. CoreML 的使用。
14. 跨平台的使用。
15. 数据库的使用以及多表连查类似的相关的内容。
16. 视频缓存机制。
17. 解释多线程，线程和队列的关系。
18. iOS 10 前后的推送封装。
19. 断点续传的实现。
20. 逆向有没有了解过。
21. 定时器 dispatch_source 和 NSTimer，NSTimer 为什么精度低。


1. 斐波那契数列算法
2. 二叉树的深度和广度遍历
3. 50000个数中前 5 个大的数
4. 二叉树的非递归前序遍历


1. 同步和异步的区别，以及它们的各自的使用场景。
2. 什么是单例模式？Objective-C 和 Swift 下分别是怎么实现的。

3. 什么是 ARC 以及 ARC 的工作原理，ARC 下会存在内存泄漏吗？
答：ARC 是由编译器和 runtime 协作的结果。ARC 中禁止手动调用 retain/release/retainCount/dealloc(dealloc 可重写，但是不能显示调用) 方法。当我们编译源码时，编译器会分析源码中每个对象的生命周期，然后基于这些对象的生命周期，来添加相应的引用计数操作代码。ARC 中新增了 weak/strong 关键属性关键字。

4. 如何最大限度的保证 TableView 的滑动流畅度。
5. 如何实现横竖屏下的三等分约束。
