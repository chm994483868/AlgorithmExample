#  数据结构与算法-十大经典排序算法

## 冒泡排序（`Bubble Sort`）
&emsp;它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。

排序过程描述：
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

+ **稳定性：** 它是指对同样的数据排序，会不会改变它的相对位置。比如 `[1, 3, 2, 4, 2]` 经过排序后，两个相同的元素 `2` 位置会不会被交换。冒泡排序是比较相邻两个元素的大小，显然不会破坏稳定性。
+ **空间复杂度：** 由于整个排序过程是在原数据上进行操作，故为 `O(1)`。
+ **平均时间复杂度：** 由于嵌套了 `2` 层循环，故为 `O(n^2)`。最好为 `O(n)`。

两个优化点：
1. 如果一趟比较下来，没有任何一对相邻元素发生过交换，则表明当前的元素列已经是有序的了。
2. 记录一趟排序下来最后发生交换时相邻元素的最低下标，且它后面的数据都是已经有序的了，下趟排序可把后面的有序的都忽略掉。

代码实现：
```c++
void bubbleSort(int nums[], int count) {
    if (nums == nullptr || count <= 0) {
        return;
    }
    
    int k = count - 1;
    for (int i = 0; i < count - 1; ++i) {
        bool noExchange = true;
        int n = 0;
        for (int j = 0; j < k; ++j) {
            if (nums[j] > nums[j + 1]) {
                swap(&nums[j], &nums[j + 1]);
                noExchange = false; // 记录本次循环是否发生过交换，如果没有，则表示当前数组已经是有序的了
                n = j; // 用于记录本次循环发生最后一次交换时的最小下标
            }
        }
        
        if (noExchange) {
            break;
        }
        k = n;
    }
}
```

## 选择排序（`Selection sort`）
&emsp;首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

+ **稳定性：** 不稳定，例如 `[2, 2, 1]` 第一趟下来，第一个 `2` 就被交换到 `1` 的位置了，两个 `2` 相对位置发生了改变。
+ **空间复杂度：** 由于整个排序过程是在原数据上进行操作，故为 `O(1)`。
+ **时间复杂度：** `O(n²)`。

代码实现：
```c++
void selectionSort(int nums[], int count) {
    if (nums == nullptr || count <= 0) {
        return;
    }
    
    for (int i = 0; i < count; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < count; ++j) {
            if (nums[j] < nums[minIndex]) {
                minIndex = j;
            }
        }
        
        swap(&nums[i], &nums[minIndex]);
    }
}
```

## 插入排序（`Insertion Sort`）
&emsp;把原数组在逻辑上分两个组，左边是已排序序列，右边是待排序序列，每次从右边序列取第一个值插入左边序列中，并保持左边序列有序，`i` 从 `1` 开始，`0` 下标元素定为左侧已排序序列的第一个元素。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

排序过程描述：
1. 从第一个元素开始，该元素可以认为已经被排序。
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描。
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置。
4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置。
5. 将新元素插入到该位置。
6. 持续把剩余元素插入左侧有序序列中。

+ **稳定性：** 由于待插入的元素遇到第一个小于或者等于自己的元素便不再进行查找交换，故稳定。
+ **空间复杂度：** 由于整个排序过程是在原数据上进行操作，故为 `O(1)`。
+ **平均时间复杂度：** 由于嵌套了 `2` 层循环，故为 `O(n^2)`。最好为 `O(n)`。

代码实现：
```c++
void insertionSort(int nums[], int count) {
    if (nums == nullptr || count <= 0) {
        return;
    }
    
    for (int i = 1; i < count; ++i) {
        for (int j = i; j > 0 && nums[j - 1] > nums[j]; --j) {
            swap(&nums[j - 1], &nums[j]);
        }
    }
}
```

## 希尔排序（`Shell's Sort`）
&emsp;希尔排序（`Shell's Sort`）是插入排序的一种又称 **“缩小增量排序”**（`Diminishing Increment Sort`），是直接插入排序算法的一种更高效的改进版本。该方法因 `D.L.Shell` 于 `1959` 年提出而得名。希尔排序是把数据按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的元素越来越多，当增量减至 1 时，整个数据恰被分成一组，算法便终止。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：
1. 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。
2. 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。

+ **稳定性：** 不稳定，例如相同元素被分到不同组时，它们最终的相对位置可能会被改变。
+ **空间复杂度：** 由于整个排序过程是在原数据上进行操作，故为 `O(1)`。
+ **时间复杂度：** 希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为 `O(n²)`，而 `Hibbard` 增量的希尔排序的时间复杂度为 `O(log n的3/2`)，希尔排序时间复杂度的下界是 `n*log2n`。

代码实现：
```c++
void shellSort(int nums[], int count) {
    if (nums == nullptr || count <= 0) {
        return;
    }
    
    //    for (int gap = count / 2; gap > 0; gap /= 2) {
    //        for (int i = 0; i < gap; ++i) {
    //            for (int j = i + gap; j < count; j += gap) {
    //                for (int k = j - gap; k >= 0 && nums[k] > nums[k + gap]; k -= gap) {
    //                    swap(&nums[k], &nums[k + gap]);
    //                }
    //            }
    //        }
    //    }
    
    for (int gap = count / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < count; ++i) {
            for (int j = i - gap; j >= 0 && nums[j] > nums[j + gap]; j -= gap) { // j 是左边元素
                swap(&nums[j], &nums[j + gap]);
            }
        }
    }
}
```
