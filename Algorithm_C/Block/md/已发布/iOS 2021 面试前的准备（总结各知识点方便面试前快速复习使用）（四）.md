# iOS 2021 面试前的准备（总结各知识点方便面试前快速复习使用）（四）

## 29. 解释 Thread Local Data。
&emsp;`pthread_getspecific` 和 `pthread_setspecific` 这两个接口分别用于获取和设置线程本地存储区的数据，在不同的线程下相同的 `pthread_key_t` 读取的结果是不同的，即线程的本地存储空间是相互隔离的，这也是线程本地存储的关键所在。

&emsp;（这里还有一个隐藏点，我们不能以面向对象的思想看待这两个接口，调用 `pthread_getspecific` 和 `pthread_setspecific` 时我们是不需要传入 pthread_t 对象的，如果我们想要在某条线程内读取其存储空间的数据，那么我们只能在当前线程内执行 `pthread_getspecific` 函数，存储同理，即我们想要操作哪条线程，那么我们只能在哪条线程内执行操作。）

&emsp;每个线程退出时调用 \__CFFinalizeRunLoop 函数。
```c++
// Called for each thread as it exits
// 每个线程退出时调用

CF_PRIVATE void __CFFinalizeRunLoop(uintptr_t data) {
    CFRunLoopRef rl = NULL;
    
    if (data <= 1) {
        // 当 data 小于等于 1 开始执行销毁
        
        // static CFLock_t loopsLock = CFLockInit;
        // loopsLock 是一个全局的锁，执行加锁
        __CFLock(&loopsLock);
        
        // 从 __CFRunLoops 全局字典中读出当前线程的 run loop 对象
        if (__CFRunLoops) {
            // 以 pthreadPointer(pthread_self()) 为 key 读取 run loop
            rl = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(pthread_self()));
            
            // 这里的 retain 是为了下面继续使用 rl，这里从 __CFRunLoops 字典中移除 rl，它的引用计数会减 1
            if (rl) CFRetain(rl);
            CFDictionaryRemoveValue(__CFRunLoops, pthreadPointer(pthread_self()));
        }
        
        __CFUnlock(&loopsLock);
    } else {
        // 初始时是 PTHREAD_DESTRUCTOR_ITERATIONS-1 是 3，那么 __CFFinalizeRunLoop 函数需要调用两次减 1，才能真正的执行 run loop 对象的销毁工作 
        _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(data - 1), (void (*)(void *))__CFFinalizeRunLoop);
    }
    // 这里的判断主线程的 run loop 是绝对不能销毁的，只能销毁子线程的 run loop，话说除了我们自己开辟的子线程外，系统会创建启动了 run loop 的子线程吗？
    if (rl && CFRunLoopGetMain() != rl) { // protect against cooperative threads
        // 如果 _counterpart 存在则进行释放
        if (NULL != rl->_counterpart) {
            CFRelease(rl->_counterpart);
            rl->_counterpart = NULL;
        }
        
        // purge all sources before deallocation
        // 在销毁 run loop 之前清除所有来源
        
        // 取得 mode 数组
        CFArrayRef array = CFRunLoopCopyAllModes(rl);
        
        // 遍历 mode 数组，移除 mode 中的所有 sources
        for (CFIndex idx = CFArrayGetCount(array); idx--;) {
            CFStringRef modeName = (CFStringRef)CFArrayGetValueAtIndex(array, idx);
            __CFRunLoopRemoveAllSources(rl, modeName);
        }
        
        // 移除 common mode 中的所有 sources
        __CFRunLoopRemoveAllSources(rl, kCFRunLoopCommonModes);
        CFRelease(array);
    }
    // 释放 rl
    if (rl) CFRelease(rl);
}
```
&emsp;销毁 run loop 对象之前，要先将其从 \__CFRunLoops 全局字典中移除，同时遍历其所有的 mode，依次移除每个 mode 中的所有 sources，最后销毁 run loop 对象。mode 销毁前同样也会释放所有的 mode item。

***

## 30. run loop 运行过程（CFRunLoopRun 函数）分析。
&emsp;在指定的条件下，运行循环退出并返回以下值:
+ `kCFRunLoopRunFinished` 运行循环模式没有源或计时器。（当 run loop 对象被标记为正在销毁时也会返回 kCFRunLoopRunFinished）
+ `kCFRunLoopRunStopped` 运行循环已使用 `CFRunLoopStop` 函数停止。
+ `kCFRunLoopRunTimedOut` 时间间隔秒数（seconds）过去了。
+ `kCFRunLoopRunHandledSource` 已处理源。此退出条件仅适用于 `returnAfterSourceHandled` 为 `true` 时。

&emsp;不能为 `mode` 参数指定 `kCFRunLoopCommonModes` 常量。运行循环总是以特定模式运行。只有在配置运行循环观察者时，以及仅在希望该观察者以多种模式运行的情况下，才能指定 common mode。

```c++
void CFRunLoopRun(void) {    /* DOES CALLOUT */
    int32_t result;
    do {
    
        // 调用 CFRunLoopRunSpecific 函数，以 kCFRunLoopDefaultMode 启动当前线程的 run loop，
        // 运行时间传入的是 10^10 秒（2777777 个小时），
        // returnAfterSourceHandled 参数传入的是 false，
        // 指示 run loop 是在处理一个源之后不退出并持续处理事件。
        
        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);
        
        CHECK_FOR_FORK();
        
    } while (kCFRunLoopRunStopped != result && kCFRunLoopRunFinished != result);
}
```
&emsp;`CFRunLoopRunSpecific` 函数内部会调用 `__CFRunLoopRun` 函数，然后可以把 `result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);` 此行的调用看作一个分界线。行前是，则是首先判断 `rl` 是否被标记为正在销毁，如果是的话则直接返回 kCFRunLoopRunFinished，否则继续往下执行，会根据 `modeName` 从 `rl` 的 `_modes` 中找到其对应的 `CFRunLoopModeRef`，如果未找到或者 `CFRunLoopModeRef` 的 sources0/sources1/timers/block 为空，则也是直接返回  kCFRunLoopRunFinished。然后是修改 `rl` 的 `_perRunData` 和 `_currentMode` 同时还会记录之前的旧值，此时一切准备就绪，在调用之前会根据 `rl` 的 `_currentMode` 的 `_observerMask` 判断是否需要回调 run loop observer 观察者来告诉它们 run loop 要进入 kCFRunLoopEntry 状态了，然后调用 `__CFRunLoopRun` 函数正式启动 run loop。

&emsp;`__CFRunLoopRun` 函数返回后则是，首先根据 `rl` 的 `_currentMode` 的 `_observerMask` 判断是否需要回调 run loop observer 观察者来告诉它们 run loop 要进入 kCFRunLoopExit 状态了。然后是把 run loop 对象恢复到之前的 `_perRunData` 和 `_currentMode`（处理 run loop 的嵌套）。

&emsp;上面描述的可能不太清晰，看下面的代码和注释已经极其清晰了。
```c++
SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl,
                            CFStringRef modeName,
                            CFTimeInterval seconds,
                            Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */
    CHECK_FOR_FORK();
    
    // 从 rl 的 _cfinfo 字段中取 rl 是否正在销毁的标记值，如果是的话，则直接返回 kCFRunLoopRunFinished
    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;
    
    // CFRunLoop 加锁
    __CFRunLoopLock(rl);
    
    // 调用 __CFRunLoopFindMode 函数从 rl 的 _modes 中找到名字是 modeName 的 run loop mode，
    // 如果找不到的话第三个参数传的是 false 则不进行新建 run loop mode，则直接返回 NULL。 
    //（CFRunLoopMode 加锁）
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);
    
    // 如果 currentMode 为 NULL 或者 currentMode 里面是空的不包含 sources0/sources1/timers/block 则 return 
    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl->_currentMode)) {
        Boolean did = false;
        
        // 如果 currentMode 存在，则进行 CFRunLoopMode 解锁，
        // 对应了上面 __CFRunLoopFindMode(rl, modeName, false) 调用内部的 CFRunLoopMode 加锁 
        if (currentMode) __CFRunLoopModeUnlock(currentMode);
        
        // CFRunLoop 解锁
        __CFRunLoopUnlock(rl);
        
        // 返回 kCFRunLoopRunFinished
        return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;
    }
    
    // __CFRunLoopPushPerRunData 函数内部是修改 rl 的 _perRunData 字段的各成员变量的值，并返回之前的 _perRunData，
    //（函数内部修改 _perRunData 的值其实是在标记 run loop 不同状态）
    //（这里的 previousPerRun 是用于下面的 __CFRunLoopRun 函数调用返回后，当前的 run loop 对象要回到之前的 _perRunData）。
    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);
    
    // previousMode 记录 rl 当前的 run loop mode，相比入参传入的 modeName 取得的 run loop mode 而言，它是之前的 run loop mode，
    // 这个 previousMode 主要用于下面的那行 __CFRunLoopRun 函数调用返回后，当前的 run loop 对象要回到之前的 run loop mode。
    //（同上面的 previousPerRun 数据，也要把当前的 run loop 对象回到之前的 _perRunData 数据的状态）
    CFRunLoopModeRef previousMode = rl->_currentMode;
    
    // 更新 rl 的 _currentMode 为入参 modeName 对应的 run loop mode 
    rl->_currentMode = currentMode;
    
    // 临时变量 result，用于当函数返回时记录 run loop 不同的退出原因
    int32_t result = kCFRunLoopRunFinished;
    
    // 判断如果 currentMode 的 _observerMask 字段中包含 kCFRunLoopEntry 的值（_observerMask 内记录了需要观察 run loop 哪些状态变化），
    // 则告诉 currentMode 的 run loop observer 发生了一个 run loop 即将进入循环的状态变化。 
    if (currentMode->_observerMask & kCFRunLoopEntry) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
    
    // 启动 run loop，__CFRunLoopRun 函数超长，可能是看源码以来最长的一个函数，下面会逐行进行细致的分析
    // ♻️♻️♻️♻️♻️♻️
    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
    
    // ⬆️⬆️⬆️ __CFRunLoopRun 函数好像也是不会返回的，当它返回时就代表当前的 run loop 要退出了。 
    
    // 同上的 kCFRunLoopEntry 进入循环的回调，这里则是退出 run loop 的回调。
    // 如果 currentMode 的 _observerMask 中包含 kCFRunLoopExit 的值，
    // 即 run loop observer 需要观察 run loop 的 kCFRunLoopExit 退出状态切换
    if (currentMode->_observerMask & kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
    
    // CFRunLoopMode 解锁
    __CFRunLoopModeUnlock(currentMode);
    
    // 销毁 rl 当前的 _perRunData，并把 previousPerRun 重新赋值给 rl 的 _perRunData 
    __CFRunLoopPopPerRunData(rl, previousPerRun);
    
    // 回到之前的 _currentMode 
    rl->_currentMode = previousMode;
    
    // CFRunLoop 解锁
    __CFRunLoopUnlock(rl);
    
    // 返回 result 结果
    return result;
}
```
&emsp;这里需要注意的一个点是 `CFRunLoopRunSpecific` 函数最后又把之前的 `previousPerRun` 和 `previousMode` 重新赋值给 run loop 的 `_perRunData` 和 `_currentMode`，它们正是用来处理 run loop 的嵌套运行的。

&emsp;`__CFRunLoopModeIsEmpty` 函数内部主要用于判断 souces0/source1/timers 是否为空，同时还有判断 rl  的 block 链表中包含的 block 是否能在指定的 rlm 下执行。

&emsp;`__CFRunLoopDoObservers` 函数是一个极重要的函数，它用于回调 run loop 发生了状态变化。

&emsp;当 run loop 的状态将要（注意这里是将要、将要、将要... kCFRunLoopExit 则除外，退出回调是真的退出完成以后的回调）发生变化时，首先根据 run loop 当前的 run loop mode 的 `_observerMask` 是否包含了此状态的变化，那么就可以调用 `__CFRunLoopDoObservers` 函数执行 run loop 状态变化的回调，我们在此状态变化里面可以做很多重要的事情，后面学习 run loop 的使用场景时我们再详细学习。（这里回顾一下前面看过的 run loop 都有哪些状态变化：即将进入 run loop、即将处理 source 事件、即将处理 timer 事件、即将休眠、休眠即将结束、run loop 退出）

&emsp;run loop observer 的回调函数。
```c++
static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__() __attribute__((noinline));
static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(CFRunLoopObserverCallBack func,
                                                                          CFRunLoopObserverRef observer,
                                                                          CFRunLoopActivity activity,
                                                                          void *info) {
    // 就是简单的带着参数调用 func 函数                                                                      
    if (func) {
        func(observer, activity, info);
    }
    
    asm __volatile__(""); // thwart tail-call optimization
}
```



## 🎉🎉🎉 未完待续...



## 什么是 ARC 以及 ARC 的工作原理，ARC 下会存在内存泄漏吗？

***

## UIView 与 CALayer  CoreAnimation 

***
