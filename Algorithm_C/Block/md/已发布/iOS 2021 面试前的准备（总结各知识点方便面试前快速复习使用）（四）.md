# iOS 2021 面试前的准备（总结各知识点方便面试前快速复习使用）（四）

## 29. 解释 Thread Local Data。
&emsp;`pthread_getspecific` 和 `pthread_setspecific` 这两个接口分别用于获取和设置线程本地存储区的数据，在不同的线程下相同的 `pthread_key_t` 读取的结果是不同的，即线程的本地存储空间是相互隔离的，这也是线程本地存储的关键所在。

&emsp;（这里还有一个隐藏点，我们不能以面向对象的思想看待这两个接口，调用 `pthread_getspecific` 和 `pthread_setspecific` 时我们是不需要传入 pthread_t 对象的，如果我们想要在某条线程内读取其存储空间的数据，那么我们只能在当前线程内执行 `pthread_getspecific` 函数，存储同理，即我们想要操作哪条线程，那么我们只能在哪条线程内执行操作。）

&emsp;每个线程退出时调用 \__CFFinalizeRunLoop 函数。
```c++
// Called for each thread as it exits
// 每个线程退出时调用

CF_PRIVATE void __CFFinalizeRunLoop(uintptr_t data) {
    CFRunLoopRef rl = NULL;
    
    if (data <= 1) {
        // 当 data 小于等于 1 开始执行销毁
        
        // static CFLock_t loopsLock = CFLockInit;
        // loopsLock 是一个全局的锁，执行加锁
        __CFLock(&loopsLock);
        
        // 从 __CFRunLoops 全局字典中读出当前线程的 run loop 对象
        if (__CFRunLoops) {
            // 以 pthreadPointer(pthread_self()) 为 key 读取 run loop
            rl = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(pthread_self()));
            
            // 这里的 retain 是为了下面继续使用 rl，这里从 __CFRunLoops 字典中移除 rl，它的引用计数会减 1
            if (rl) CFRetain(rl);
            CFDictionaryRemoveValue(__CFRunLoops, pthreadPointer(pthread_self()));
        }
        
        __CFUnlock(&loopsLock);
    } else {
        // 初始时是 PTHREAD_DESTRUCTOR_ITERATIONS-1 是 3，那么 __CFFinalizeRunLoop 函数需要调用两次减 1，才能真正的执行 run loop 对象的销毁工作 
        _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(data - 1), (void (*)(void *))__CFFinalizeRunLoop);
    }
    // 这里的判断主线程的 run loop 是绝对不能销毁的，只能销毁子线程的 run loop，话说除了我们自己开辟的子线程外，系统会创建启动了 run loop 的子线程吗？
    if (rl && CFRunLoopGetMain() != rl) { // protect against cooperative threads
        // 如果 _counterpart 存在则进行释放
        if (NULL != rl->_counterpart) {
            CFRelease(rl->_counterpart);
            rl->_counterpart = NULL;
        }
        
        // purge all sources before deallocation
        // 在销毁 run loop 之前清除所有来源
        
        // 取得 mode 数组
        CFArrayRef array = CFRunLoopCopyAllModes(rl);
        
        // 遍历 mode 数组，移除 mode 中的所有 sources
        for (CFIndex idx = CFArrayGetCount(array); idx--;) {
            CFStringRef modeName = (CFStringRef)CFArrayGetValueAtIndex(array, idx);
            __CFRunLoopRemoveAllSources(rl, modeName);
        }
        
        // 移除 common mode 中的所有 sources
        __CFRunLoopRemoveAllSources(rl, kCFRunLoopCommonModes);
        CFRelease(array);
    }
    // 释放 rl
    if (rl) CFRelease(rl);
}
```
&emsp;销毁 run loop 对象之前，要先将其从 \__CFRunLoops 全局字典中移除，同时遍历其所有的 mode，依次移除每个 mode 中的所有 sources，最后销毁 run loop 对象。mode 销毁前同样也会释放所有的 mode item。

***

## 30. run loop 运行过程（CFRunLoopRun 函数摘要）分析。
&emsp;在指定的条件下，运行循环退出并返回以下值:
+ `kCFRunLoopRunFinished` 运行循环模式没有源或计时器。（当 run loop 对象被标记为正在销毁时也会返回 kCFRunLoopRunFinished）
+ `kCFRunLoopRunStopped` 运行循环已使用 `CFRunLoopStop` 函数停止。
+ `kCFRunLoopRunTimedOut` 时间间隔秒数（seconds）过去了。
+ `kCFRunLoopRunHandledSource` 已处理源。此退出条件仅适用于 `returnAfterSourceHandled` 为 `true` 时。

&emsp;不能为 `mode` 参数指定 `kCFRunLoopCommonModes` 常量。运行循环总是以特定模式运行。只有在配置运行循环观察者时，以及仅在希望该观察者以多种模式运行的情况下，才能指定 common mode。

```c++
void CFRunLoopRun(void) {    /* DOES CALLOUT */
    int32_t result;
    do {
    
        // 调用 CFRunLoopRunSpecific 函数，以 kCFRunLoopDefaultMode 启动当前线程的 run loop，
        // 运行时间传入的是 10^10 秒（2777777 个小时），
        // returnAfterSourceHandled 参数传入的是 false，
        // 指示 run loop 是在处理一个源之后不退出并持续处理事件。
        
        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);
        
        CHECK_FOR_FORK();
        
    } while (kCFRunLoopRunStopped != result && kCFRunLoopRunFinished != result);
}
```
&emsp;`CFRunLoopRunSpecific` 函数内部会调用 `__CFRunLoopRun` 函数，然后可以把 `result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);` 此行的调用看作一个分界线。行前是，则是首先判断 `rl` 是否被标记为正在销毁，如果是的话则直接返回 kCFRunLoopRunFinished，否则继续往下执行，会根据 `modeName` 从 `rl` 的 `_modes` 中找到其对应的 `CFRunLoopModeRef`，如果未找到或者 `CFRunLoopModeRef` 的 sources0/sources1/timers/block 为空，则也是直接返回  kCFRunLoopRunFinished。然后是修改 `rl` 的 `_perRunData` 和 `_currentMode` 同时还会记录之前的旧值，此时一切准备就绪，在调用之前会根据 `rl` 的 `_currentMode` 的 `_observerMask` 判断是否需要回调 run loop observer 观察者来告诉它们 run loop 要进入 kCFRunLoopEntry 状态了，然后调用 `__CFRunLoopRun` 函数正式启动 run loop。

&emsp;`__CFRunLoopRun` 函数返回后则是，首先根据 `rl` 的 `_currentMode` 的 `_observerMask` 判断是否需要回调 run loop observer 观察者来告诉它们 run loop 要进入 kCFRunLoopExit 状态了。然后是把 run loop 对象恢复到之前的 `_perRunData` 和 `_currentMode`（处理 run loop 的嵌套）。

&emsp;上面描述的可能不太清晰，看下面的代码和注释已经极其清晰了。
```c++
SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl,
                            CFStringRef modeName,
                            CFTimeInterval seconds,
                            Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */
    CHECK_FOR_FORK();
    
    // 从 rl 的 _cfinfo 字段中取 rl 是否正在销毁的标记值，如果是的话，则直接返回 kCFRunLoopRunFinished
    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;
    
    // CFRunLoop 加锁
    __CFRunLoopLock(rl);
    
    // 调用 __CFRunLoopFindMode 函数从 rl 的 _modes 中找到名字是 modeName 的 run loop mode，
    // 如果找不到的话第三个参数传的是 false 则不进行新建 run loop mode，则直接返回 NULL。 
    //（CFRunLoopMode 加锁）
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);
    
    // 如果 currentMode 为 NULL 或者 currentMode 里面是空的不包含 sources0/sources1/timers/block 则 return 
    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl->_currentMode)) {
        Boolean did = false;
        
        // 如果 currentMode 存在，则进行 CFRunLoopMode 解锁，
        // 对应了上面 __CFRunLoopFindMode(rl, modeName, false) 调用内部的 CFRunLoopMode 加锁 
        if (currentMode) __CFRunLoopModeUnlock(currentMode);
        
        // CFRunLoop 解锁
        __CFRunLoopUnlock(rl);
        
        // 返回 kCFRunLoopRunFinished
        return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;
    }
    
    // __CFRunLoopPushPerRunData 函数内部是修改 rl 的 _perRunData 字段的各成员变量的值，并返回之前的 _perRunData，
    //（函数内部修改 _perRunData 的值其实是在标记 run loop 不同状态）
    //（这里的 previousPerRun 是用于下面的 __CFRunLoopRun 函数调用返回后，当前的 run loop 对象要回到之前的 _perRunData）。
    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);
    
    // previousMode 记录 rl 当前的 run loop mode，相比入参传入的 modeName 取得的 run loop mode 而言，它是之前的 run loop mode，
    // 这个 previousMode 主要用于下面的那行 __CFRunLoopRun 函数调用返回后，当前的 run loop 对象要回到之前的 run loop mode。
    //（同上面的 previousPerRun 数据，也要把当前的 run loop 对象回到之前的 _perRunData 数据的状态）
    CFRunLoopModeRef previousMode = rl->_currentMode;
    
    // 更新 rl 的 _currentMode 为入参 modeName 对应的 run loop mode 
    rl->_currentMode = currentMode;
    
    // 临时变量 result，用于当函数返回时记录 run loop 不同的退出原因
    int32_t result = kCFRunLoopRunFinished;
    
    // 判断如果 currentMode 的 _observerMask 字段中包含 kCFRunLoopEntry 的值（_observerMask 内记录了需要观察 run loop 哪些状态变化），
    // 则告诉 currentMode 的 run loop observer 发生了一个 run loop 即将进入循环的状态变化。 
    if (currentMode->_observerMask & kCFRunLoopEntry) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
    
    // 启动 run loop，__CFRunLoopRun 函数超长，可能是看源码以来最长的一个函数，下面会逐行进行细致的分析
    // ♻️♻️♻️♻️♻️♻️
    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
    
    // ⬆️⬆️⬆️ __CFRunLoopRun 函数好像也是不会返回的，当它返回时就代表当前的 run loop 要退出了。 
    
    // 同上的 kCFRunLoopEntry 进入循环的回调，这里则是退出 run loop 的回调。
    // 如果 currentMode 的 _observerMask 中包含 kCFRunLoopExit 的值，
    // 即 run loop observer 需要观察 run loop 的 kCFRunLoopExit 退出状态切换
    if (currentMode->_observerMask & kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
    
    // CFRunLoopMode 解锁
    __CFRunLoopModeUnlock(currentMode);
    
    // 销毁 rl 当前的 _perRunData，并把 previousPerRun 重新赋值给 rl 的 _perRunData 
    __CFRunLoopPopPerRunData(rl, previousPerRun);
    
    // 回到之前的 _currentMode 
    rl->_currentMode = previousMode;
    
    // CFRunLoop 解锁
    __CFRunLoopUnlock(rl);
    
    // 返回 result 结果
    return result;
}
```
&emsp;这里需要注意的一个点是 `CFRunLoopRunSpecific` 函数最后又把之前的 `previousPerRun` 和 `previousMode` 重新赋值给 run loop 的 `_perRunData` 和 `_currentMode`，它们正是用来处理 run loop 的嵌套运行的。

&emsp;`__CFRunLoopModeIsEmpty` 函数内部主要用于判断 souces0/source1/timers 是否为空，同时还有判断 rl  的 block 链表中包含的 block 是否能在指定的 rlm 下执行。

&emsp;`__CFRunLoopDoObservers` 函数是一个极重要的函数，它用于回调 run loop 发生了状态变化。

&emsp;当 run loop 的状态将要（注意这里是将要、将要、将要... kCFRunLoopExit 则除外，退出回调是真的退出完成以后的回调）发生变化时，首先根据 run loop 当前的 run loop mode 的 `_observerMask` 是否包含了此状态的变化，那么就可以调用 `__CFRunLoopDoObservers` 函数执行 run loop 状态变化的回调，我们在此状态变化里面可以做很多重要的事情，后面学习 run loop 的使用场景时我们再详细学习。（这里回顾一下前面看过的 run loop 都有哪些状态变化：即将进入 run loop、即将处理 source 事件、即将处理 timer 事件、即将休眠、休眠即将结束、run loop 退出）

&emsp;run loop observer 的回调函数。
```c++
static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__() __attribute__((noinline));
static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(CFRunLoopObserverCallBack func,
                                                                          CFRunLoopObserverRef observer,
                                                                          CFRunLoopActivity activity,
                                                                          void *info) {
    // 就是简单的带着参数调用 func 函数                                                                      
    if (func) {
        func(observer, activity, info);
    }
    
    asm __volatile__(""); // thwart tail-call optimization
}
```

&emsp;\_\_CFRunLoopRun 内层的 do while 循环主要是用于 "保持" run looop 的睡眠状态的，直到需要被唤醒了才会跳出这个 do while 循环。只有在下面的事件发生时才会进行唤醒：
1. 基于端口的输入源（port-based input source）（source1）的事件到达。
2. CFRunLoopMode 中的 timers 触发。（CFRunLoopMode 可添加多个 timer，它们共用一个 _timerPort 唤醒 run loop，并且会计算所有 timer 中最近的下次要触发的 timer 的时间）
3. 为 run loop 设置的超时时间过期。
4. run loop 被显式唤醒。（被其他什么调用者手动唤醒）

&emsp;`CFRunLoopWakeUp` 函数内部，通过 run loop 的 `_wakeUpPort` 唤醒端口来唤醒 run loop 对象。

&emsp;`__CFRunLoopDoBlocks` 函数内部是遍历 run loop 的 block 的链表，在指定的 rlm 下执行 block，执行完节点的 block 以后会把该节点从链表中移除，最后更新链表的头节点和尾节点。

&emsp;`__CFRunLoopDoSources0` 函数是遍历收集 rlm 的 \_source0 把 Valid、Signaled 的 CFRunLoopSourceRef 收集起来，然后执行以 source0 的 info 为参数执行 source0 的 perform 函数，且会把 CFRunLoopSourceRef 置为 UnsetSignaled，等待被再次标记并执行。

&emsp;`__CFRunLoopDoTimers` 函数执行 CFRunLoopTimerRef 的回调函数并更新其 `_fireTSR` 和 `_nextFireDate`。

***

## 31. mach_msg 函数。
&emsp;Run Loop 最核心的事情就是保证线程在没有消息时休眠以避免系统资源占用，有消息时能够及时唤醒。Run Loop 的这个机制完全依靠系统内核来完成，具体来说是苹果操作系统核心组件 Darwin 中的 Mach 来完成的。**Mach 与 BSD、File System、Mach、Networking 共同位于 Kernel and Device Drivers 层。**

&emsp;在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为 “对象”，和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。“消息”（mach msg）是 Mach 中最基础的概念，消息在两个端口 (mach port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。

&emsp;Mach 是 Darwin 的核心，可以说是内核的核心，提供了进程间通信（IPC）、处理器调度等基础服务。在 Mach 中，进程、线程间的通信是以消息（mach msg）的方式来完成的，而消息则是在两个 mach port 之间进行传递（或者说是通过 mach port 进行消息的传递）（这也正是 Source1 之所以称之为 Port-based Source 的原因，因为它就是依靠 mach msg 发送消息到指定的 mach port 来唤醒 run loop）。

&emsp;为了实现消息的发送和接收，mach_msg 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数 mach_msg_trap，陷阱这个概念在 Mach 中等同于系统调用。当在用户态调用 mach_msg_trap 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg 函数会完成实际的工作。

&emsp;run loop 的核心就是一个 mach_msg ，run loop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，会看到主线程调用栈是停留在 mach_msg_trap 这个地方

&emsp;（mach_msg 函数可以设置 timeout 参数，如果在 timeout 到来之前没有读到 msg，当前线程的 run loop 会处于休眠状态。）

&emsp;消息的发送和接收统一使用 `mach_msg` 函数，而 `mach_msg` 的本质是调用了 `mach_msg_trap`，这相当于一个系统调用，会触发内核态与用户态的切换。

&emsp;点击 App 图标，App 启动完成后处于静止状态（一般如果没有 timer 需要一遍一遍执行的话），此时主线程的 run loop 会进入休眠状态，通过在主线程的 run loop 添加 CFRunLoopObserverRef 在回调函数中可看到主线程的 run loop 的最后活动状态是 kCFRunLoopBeforeWaiting，此时点击 Xcode 控制台底部的 Pause program execution 按钮，从 Xcode 左侧的 Debug navigator 可看到主线程的调用栈停在了 mach_msg_trap。

&emsp;\_timerPort 是 \__CFRunLoopMode 的一个成员变量。在 macOS 下同时支持 dispatch_source 和 mk 构建 timer，在 iOS 下则只支持使用 mk。这里我们只关注 \_timerPort。我们在 Cocoa Foundation 层会通过手动创建并添加计时器 NSTimer 到  run loop 的指定 run loop mode 下，同样在 Core Foundation 层会通过创建 CFRunLoopTimerRef 实例并把它添加到 run loop 的指定 run loop mode 下，内部实现是则是把 CFRunLoopTimerRef 实例添加到 run loop mode 的 \_timers 集合中，当 \_timers 集合中的计时器需要执行时则正是通过 \_timerPort 来唤醒 run loop，且 run loop mode 的 \_timers 集合中的所有计时器共用这一个 \_timerPort。

&emsp;这里我们可以做一个验证，我们为主线程添加一个 CFRunLoopOberver 观察 main run loop 的状态变化和一个 1 秒执行一次的 NSTimer。程序运行后可看到一直如下的重复打印：(代码过于简单，这里就不贴出来了)
```c++
...
⏰⏰⏰ timer 回调...
🎯... kCFRunLoopBeforeTimers
🎯... kCFRunLoopBeforeSources
🎯... kCFRunLoopBeforeWaiting
🎯... kCFRunLoopAfterWaiting
⏰⏰⏰ timer 回调...
🎯... kCFRunLoopBeforeTimers
🎯... kCFRunLoopBeforeSources
🎯... kCFRunLoopBeforeWaiting
🎯... kCFRunLoopAfterWaiting
...
```
&emsp;计时器到了触发时间唤醒 run loop（kCFRunLoopAfterWaiting）执行计时器的回调，计时器回调执行完毕后 run loop 又进入休眠状态（kCFRunLoopBeforeWaiting）然后到达下次计时器触发时间时 run loop 再次被唤醒，如果不手动停止计时器的话则会这样一直无限重复下去。 

## 32. 回顾 run loop mode item（Source0 和 Source1 的区别）。
&emsp;我们首先再次回顾一下 Source/Timer/Observer，因为 run loop 正是通过这些 run loop mode item 来向外提供功能支持的。

1. CFRunLoopSourceRef 是事件产生的地方。Source 有两个版本：Source0 和 Source1。
+ Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 run loop，让其处理这个事件。
+ Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息（mach_msg），这种 Source 能主动唤醒 run loop 的线程。

&emsp;Source0 中仅有一些回调函数会在 run loop 的本次循环中执行，而 Source1 中有 mach port 可用来主动唤醒 run loop。

2. CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是 toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 run loop 时，run loop 会注册对应的时间点，当时间点到时，run loop会被唤醒以执行那个回调。
3. CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 run loop 的状态发生变化时，观察者就能通过这个回调接收到。


## 🎉🎉🎉 未完待续...



## 什么是 ARC 以及 ARC 的工作原理，ARC 下会存在内存泄漏吗？

***

## UIView 与 CALayer  CoreAnimation 

***
