# iOS 2021 面试前的准备（精简各知识点方便面试前快速复习使用）

> &emsp;博主前期通读了 Apple 的五份源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)、[libdispatch-1173.40.5](https://opensource.apple.com/tarballs/libdispatch/)、[CF-1151.16](https://opensource.apple.com/tarballs/CF/)、[libmalloc-283.100.6](https://opensource.apple.com/tarballs/libmalloc/)、[libclosure-74](https://opensource.apple.com/source/libclosure/) 基本对 iOS 的大部分底层原理都有了一个基础的认知，然后算法部分的话是专注刷了两遍 《剑指 Offer》（在 IDE 里可以完成默写，完全手写的话可能还需要一些练习）。那么既然是面试肯定免不了要刷题，题目的话就从网络搜集各位大佬面试时的题目，然后试着从自己的理解上给题目作出解答，如有错误的地方还望大家进行指正。   

## 1. KVC 的工作原理。
&emsp;[iOS《Key-Value Coding Programming Guide》官方文档](https://juejin.cn/post/6915290445069156366) 和 [iOS《Key-Value Coding Programming Guide》官方文档](https://juejin.cn/post/6915290445069156366) 这两篇是 KVC 和 KVO 官方文档的翻译，如果需要的话可以进行详细阅读，下面对它们的原理进行简要总结。

&emsp;Key-Value Coding（键值编码）是由 NSKeyValueCoding 非正式协议启用的一种机制，对象采用这种机制来提供对其属性/成员变量的**间接访问**。当一个对象符合键值编码时，它的所有属性/成员变量可以通过一个简洁、统一的消息传递接口（`setValue:forKey:`）通过字符串参数寻址。这种**间接访问机制补充了实例变量及其相关访问器方法（getter 方法）提供的直接访问**。

&emsp;KVC 在代码实现层面则是在 Foundation 框架下有一个 NSKeyValueCoding.h 文件，其内部定义了多组分类接口，其中包括：@interface NSObject(NSKeyValueCoding)、@interface NSArray<ObjectType>(NSKeyValueCoding)、@interface NSDictionary<KeyType, ObjectType>(NSKeyValueCoding)、@interface NSMutableDictionary<KeyType, ObjectType>(NSKeyValueCoding)、@interface NSOrderedSet<ObjectType>(NSKeyValueCoding)、@interface NSSet<ObjectType>(NSKeyValueCoding)，其中 NSObject 基类已经实现了 NSKeyValueCoding 机制的所有接口，所以我们自己创建的 NSObject 子类都是支持 KVC 的，然后 NSArray、NSDictionary、NSMutableDictionary、NSOrderedSet、NSSet 这些子类则是对 `setValue:forKey:` 和 `valueForKey:` 函数进行重载。例如当对一个 NSArray 对象调用 `setValue:forKey:` 函数时，它内部是对数组中的每个元素调用 `setValue:forKey:` 函数。当对一个 NSArray 对象调用 `valueForKey:` 函数时，它返回一个数组，其中包含在数组的每个元素上调用 `valueForKey:` 的结果。返回的数组将包含 `NSNull` 元素，指代的是数组中某些元素调用 `valueForKey:` 函数返回 nil 的情况。

&emsp;集合运算符（@avg、@count、@max、@min、@sum）数组运算符（@distinctUnionOfObjects、@unionOfObjects、）嵌套运算符（@distinctUnionOfArrays、@unionOfArrays、@distinctUnionOfSets）。

&emsp;非对象类型的属性的包装和解包，如 int/float 包装成 NSNumber，struct（NSPoint、NSRange、NSRect、NSSize） 包装成 NSValue。

&emsp;在给定键参数作为输入的情况下，`valueForKey:` 的默认实现执行以下过程。（在接收 `valueForKey:` 调用的类对象内部进行操作）

1. 在实例中搜索第一个名为 `get<Key>`、`<key>`、`is<Key>` 或 `\_<key>` 的访问器方法。如果找到了，则调用它并继续执行步骤 5 并返回结果。否则继续下一步。（如果想简单描述的话可以把步骤 2 和 3 省略，2 和 3 针对是一对多关系的搜索过程，如 NSArray 和 NSSet 类型属性的搜索过程）

2. 如果找不到简单的访问器方法，在实例中搜索名称与 `countOf<Key>`、`objectIn<Key>AtIndex:`（对应于 NSArray 类定义的原始方法） 和 `<key>AtIndexes:`（对应于 NSArray 的 `objectsAtIndexes:` 方法）模式匹配的方法。
  如果找到其中的第一个以及其他两个中的至少一个，则创建一个响应所有 NSArray 方法的集合代理对象（collection proxy object），并返回该对象。否则，请继续执行步骤 3。
  代理对象随后将接收到的任何 NSArray 消息转换为 `countOf<Key>`、`objectIn<Key>AtIndex:` 和 `<Key>AtIndexes:` 消息的组合，并将其转换为创建它的键值编码兼容对象。如果原始对象还实现了一个名为 `get<Key>:range:` 之类的可选方法，则代理对象也将在适当时使用该方法。实际上，代理对象与键值编码兼容的对象一起工作，允许底层属性的行为就像 NSArray 一样，即使它不是。
  
3. 如果找不到简单的访问器方法或数组访问方法组，请查找名为 `countOf<Key>`、`enumeratorOf<Key>` 和 `memberOf<Key>` 的三重方法。（对应于 NSSet 类定义的原始方法）
  如果找到所有三个方法，请创建一个响应所有 NSSet 方法的集合代理对象，并返回该对象。否则，继续执行步骤 4。
  代理对象随后将接收到的任何 NSSet 消息转换为 `countOf<Key>`、`enumeratorOf<Key>` 和 `memberOf<Key>` 消息的某种组合，以创建它的对象。实际上，代理对象与键值编码兼容对象一起工作，使得基础属性的行为就像 NSSet 一样，即使它不是 NSSet。
  
4. 如果找不到简单的访问器方法或集合访问方法组，并且如果 receiver 的类方法 `accessInstanceVariablesDirectly` 返回 YES，则按该顺序搜索名为 `\_<key>`、`\_is<Key>`、`<key>` 或 `is<Key>` 的实例变量。如果找到，则直接获取实例变量的值并继续执行步骤 5。否则，继续进行步骤 6。

5. 如果检索到的属性值是对象指针，则只需返回结果。
  如果该值是 NSNumber 支持的标量类型，则将其存储在 NSNumber 实例中并返回它。
  如果结果是 NSNumber 不支持的标量类型，则转换为 NSValue 对象并返回该对象。
  
6. 如果所有方法均失败，则调用 `valueForUndefinedKey:`。默认情况下，这会引发一个 NSUndefinedKeyException 异常，但是 NSObject 的子类可以提供特定于键的行为（子类重写 `valueForUndefinedKey:` 函数，那进一步我们自行添加一个 NSObject 分类重写 `valueForUndefinedKey:` 方法呢？）。

&emsp;`setValue:forKey:` 的默认实现，给定 key 和 value 参数作为输入，尝试将名为 key 的属性设置为 value，使用以下过程在接收到调用的对象内部：

1. 按此顺序查找名为 `set<Key>:` 或 `\_set<Key>` 的第一个访问器。如果找到了，则使用 value（或根据需要解包 value 的值）调用它并完成。

2. 如果未找到简单的访问器，并且类方法 `accessInstanceVariablesDirectly` 返回 YES，按该顺序查找名称类似于 `\_<key>`、`\_is<Key>`、`<key>` 或 `is<Key>` 的实例变量。如果找到，则直接使用 value（或根据需要解包 value 的值）设置实例变量并完成操作。

3. 在找不到访问器或实例变量时，调用 `setValue:forUndefinedKey:`。这在默认情况下会引发 NSUndefinedKeyException 异常，但 NSObject 的子类可能会提供键特定的行为。（由子类重写 `setValue:forUndefinedKey:`）

> &emsp;NOTE: 当你使用非对象属性的 nil 值调用其中一个键值编码协议 setter 时，setter 没有明显的常规操作过程可采取。因此，它向接收 setter 调用的对象发送 `setNilValueForKey:` 消息。此方法的默认实现会引发 NSInvalidArgumentException 异常，但子类可能会重写此行为，如处理非对象值中所述，例如设置标记值或提供有意义的默认值。

&emsp;键值编码是高效的，尤其是当你依靠默认实现来完成大部分工作时，但是它确实添加了一个间接级别，该级别比直接的方法调用稍慢。只有当你可以从它提供的灵活性中获益或者允许你的对象参与依赖于它的 Cocoa 技术时，才使用键值编码。

***

## 2. KVO 的工作原理。（追问 KVO 动态生成的新类重写了属性的 Setter 函数后，那原始手动实现的 Setter 函数会被覆盖吗？对对象的某个属性添加观察者后那对象的 isa 指向和 class 函数会发生什么变化？移除观察者后呢？）
&emsp;Key-Value Observing（键值观察）是一种机制，它允许将其他对象的指定属性的更改通知给对象。

> &emsp;KVO （自动键值观察）是通过 isa-swizzling （交换）实现的。基本的流程就是编译器自动为被观察者对象创造一个派生类（此派生类的父类是被观察者对象所属的类），并将被观察者对象的 isa  指向这个派生类（类名是 NSKVONotifying_XXX）。如果用户注册了对此目标对象的某一个属性的观察，那么此派生类会重写这个属性的 setter 方法，并在其中添加进行通知的代码。Objective-C 在发送消息的时候，会通过 isa 指针找到当前对象所属的类对象。而类对象中保存着当前对象可调用的实例方法，因此在向此对象发送消息时候，实际上是发送到了派生类对象的方法。由于编译器对派生类的方法进行了重写，并添加了通知代码，因此会向注册的观察者对象发送通知。注意派生类只重写注册了观察者的属性方法。

```c++
-(void)setValue:(id)obj {
    [self willChangeValueForKey:@"keyPath"];
    
    // 这里内部使用 super 调用，由于当前派生类的 super 正是指向原类，所以不影响原类中自己手动实现的 setter 函数调用（去 58 面试时遇到了这个问题） 
    [super setValue:obj];
    
    [self didChangeValueForKey:@"keyPath"];
}
```

&emsp;如下示例代码中定义的 Student 类，当对其 name 属性注册了观察者后，打印其 class 和 isa 如下：
```c++
@interface Student : NSObject
@property (nonatomic, copy) NSString *name;
@end

// 对 self.student 添加观察者后 class 函数返回的依然是 Student
NSLog(@"🤍🤍 %@", [self.student class]);

// object_getClass 方法返回 isa 指向却是 NSKVONotifying_Student
NSLog(@"🤍🤍 %@", object_getClass(self.student));

// 控制台打印:
🤍🤍 Student
🤍🤍 NSKVONotifying_Student
 
// 然后移除 self.student 的观察者后，object_getClass(self.student) 返回的则是 Student。
```

> &emsp;简而言之，Apple 使用了一种 isa 交换的技术，当 student 被观察后，student 对象的 isa 指针被指向了一个新建的 Student 的子类 NSKVONotifying_Student，且这个子类重写了被观察属性的 setter 方法、class 方法、dealloc 和 \_isKVO 方法，然后使 student 对象的 isa 指针指向这个新建的类，然后事实上 student 变为了NSKVONotifying_Student 的实例对象，执行方法要从这个类的方法列表里找。dealloc 方法：观察者移除后使 class 变回去 Student（通过 isa 指向）, \_isKVO 方法判断被观察者自己是否同时也观察了其他对象。（同时苹果警告我们，通过 isa 获取类的类型是不可靠的，通过 class 方法才能得到正确的类）[用代码探讨 KVC/KVO 的实现原理](https://juejin.cn/post/6844903587898753037)

+ 验证观察者提前释放了且被观察者没有主动移除该观察者，那被观察者的 isa 会不会回归为原类？
  不会回归原类，还是 NSKVONotifying_xxx 类，且此时再向观察者发送通知（observeValueForKeyPath:ofObject:change:context:）会发生野指针访问 crash。
+ 验证 KVO 中编译器派生的新类的父类是不是原类？
  是原类，例如打印 `class_getSuperclass(object_getClass(self.vcTestObjc))`  时可看到 NSKVONotifying_TestObjc 的父类是 TestObjc。
+ 如何手动触发 KVO？
```c++
[self willChangeValueForKey:@"vcTestObjcTWO"];

// 这里我们直接给实例变量赋值，不执行 vcTestObjcTWO 属性的 Setter 函数则会手动触发一次监听通知，
// 如果是使用 self.vcTestObjcTWO 赋值，则会调用 Setter 函数，此时手动加自动便会执行两次监听通知。 
_vcTestObjcTWO = [[TestObjc alloc] init];

[self didChangeValueForKey:@"vcTestObjcTWO"];
```

***

## 3. iOS 中的方法缓存、快速查找、慢速查找流程。
&emsp;首先是 cache_t cache 的位置，它是 objc_class 结构体的第三个成员变量（起始地址偏移 16 个字节），类型是 cache_t 结构体，从数据结构角度及使用方法来看 `cache_t` 的话，它是一个 `SEL`  作为 `Key` ，`SEL + IMP(bucket_t)` 作为 `Value` 的哈希表。
```c++
struct objc_class : objc_object {
// Class ISA; // objc_class 继承自 objc_object，所以其第一个成员变量其实是 isa_t isa 
Class superclass; // 父类指针
cache_t cache; // formerly cache pointer and vtable 以前缓存指针和虚函数表
...
};
```
&emsp;**方法缓存插入的执行过程：** 把指定的 `sel` 和 `imp` 插入到 `cache_t` 中，如果开始是空状态，则首先会初始一个容量为 4 散列数组再进行插入，其它情况插入之前会计算已用的容量占比是否到了临界值 3/4，如果是则首先进行扩容扩大为 2 倍，然后再进行插入操作（哈希函数是直接 sel 和 mask 与操作），如果还没有达到则直接插入，插入操作如果发生了哈希冲突则以开放寻址法进行哈希探测。cache 扩容时为了性能考虑不会把旧的 buckets 数据重新哈希放入新内存中，会把旧的 buckets 放进一个等待释放的数组中，但是也不会立即就释放旧的 bukckts，而是将旧的 buckets 存放到全局的 static bucket_t **garbage_refs 数组中，以便稍后释放，注意这里是稍后释放。因为此时可能其他线程正在进行方法缓存查找。当 garbage_refs 数组的内存容量达到阈值 32*1024 字节时会进行释放旧的 buckets 数据。（_collecting_in_critical 函数内部会判断当前是否有别的线程在查找旧 buckets 数据，如果没有到话才会进行释放旧 buckets 数据）

&emsp;**objc_msgSend 函数** 那么 `objc_msgSend` 是怎么实现的呢？乍看它以为是一个 `C/C++` 函数，但它其实是汇编实现的。
使用汇编的原因，除了 **快速，方法的查找操作是很频繁的，汇编是相对底层的语言更容易被机器识别，节省中间的一些编译过程**  还有一些重要的原因，**用汇编实现，是为了应对不同的 “Calling convention”，把函数调用前的栈和寄存器的参数、状态设置，交给编译器去处理**。

&emsp;objc_msgSend 函数查找 cache 的过程，x0 保存 self，x1 保存 \_cmd，后续的 x2-x7 依次是存放其他参数（超过 7 个参数时存在栈中）。 在 arm64 下首先判断 self 是否小于等于 0，如果是的话判断是 TaggedPointer （TaggedPointer 在 arm64 下，最高位为 1，作为有符号数 < 0）还是 nil，如果是 nil 则跳转到 LReturnZero 把寄存器清 0，如果是 TaggedPointer（从类表中取 Class）  或正常的对象（从 isa 中取 Class，3～36 bit），则首先取得它们所属的类，然后是 CacheLookup 在缓存中查找或进行完整方法查找。缓存查找首先找到从 Class 起始地址偏移 16 字节取得 cache_t cache 成员变量，然后根据传入的 \_cmd 在 buckets 哈希表中进行哈希查找（\_cmd & mask）（开放寻址法），缓存命中时 TailCallCachedImp 内部 br 指令调用 \_cmd 对应的 imp（其他参数都已经在寄存器中存放好）（在缓存表进行哈希查找的过程中有一个细节可展开可不展开，当到达缓存表头后，继续从缓存表尾开始全缓存表扫描，直至重新回到缓存表头。是为了处理缓存被破坏时的情况。）如果缓存未命中的情况下，则都会调用 \_\_objc_msgSend_uncached 内部则是调用 MethodTableLookup（即查询方法列表） 进行方法查找。（即大家常说的慢速查找）

&emsp;缓存未命中时，都会走到 \_\_objc_msgSend_uncached 去处理。\_\_objc_msgSend_uncached 的实现很简单，调用 MethodTableLookup 进行方法查找。MethodTableLookup 的核心则是进行一个 lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER) 的查找，找到 imp 后同样是 TailCallFunctionPointer 调用，下面我们看 lookUpImpOrForward 函数，它是一个 C 函数定义在 objc-runtime-new.mm 文件中。

> + C/C++ 中调用 汇编 ，去查找汇编时，C/C++ 调用的方法需要多加一个下划线
  + 汇编 中调用 C/C++ 方法时，去查找 C/C++ 方法，需要将汇编调用的方法去掉一个下划线

&emsp;当缓存未命中时首先进行的是在当前类中进行慢速查找，如果还是未找到的话，会去父类的缓存中查找，依然未命中的话则是在父类中进行慢速查找。沿着继承链一直重复缓存查找和慢速查找直到根类。在父类中找到的方法会被缓存到当前类的 cache 中。

&emsp;lookUpImpOrForward 函数开始先进行 是否是已知类、类是否实现、是否初始化三个判断，然后是 for 循环沿着类继承链或者元类继承链进行顺序查找，在 curClass 的方法列表（数组或者是二维数组）中使用二分查找算法查找方法，如果找到的话写入 cls 的 cache 中并返回 imp。如果 for 循环结束都没有找到则判断是否进行动态方法解析，即我们熟悉的 resolveInstanceMethod 和 resolveClassMethod。 





&emsp;参考链接🔗🔗：
+ [iOS 从源码解析Runtime (八)：聚焦cache_t及方法缓存实现相关内容篇(1)](https://juejin.cn/post/6878592460739182599)
+ [iOS 从源码解析Runtime (九)：聚焦cache_t objc-msg-arm64.s解析(2)](https://juejin.cn/post/6880503993798230030)
+ [iOS 从源码解析Runtime (十)：聚焦cache_t objc-msg-arm64.s补充(3)](https://juejin.cn/post/6880774335192432647)
+ [翻译-为什么objc_msgSend必须用汇编实现](http://tutuge.me/2016/06/19/translation-why-objcmsgsend-must-be-written-in-assembly/)

https://www.jianshu.com/p/90863cfb6657
https://www.jianshu.com/u/1e8432e01e5a
https://mp.weixin.qq.com/s/EvsKylCWew8-pCZwMqw2og

## 4. 什么是 ARC 以及 ARC 的工作原理，ARC 下会存在内存泄漏吗？




***

## 5. UIView 与 CALayer  CoreAnimation 





1. iOS 屏幕成像原理（离屏渲染 Off-screen Rendered）。
2. atomic、nonatomic、strong（retain）、weak（unsafe_unretained）、assign 属性修饰符的工作原理。（\_\_strong、\_\_weak、\_\_unsafe_unretained）
3. weak 底层实现原理。
  + DisguisedPtr<objc_object> DisguisedPtr<objc_object *> 伪装指针，把地址变为整数保存。
  + typedef DisguisedPtr<objc_object *> weak_referrer_t; weak 变量的地址，即一个指针的指针。
  + struct weak_entry_t 保存某个对象的所有 weak 变量地址的哈希表。
  + struct weak_table_t 保存对象和其 weak_entry_t 的哈希表。
  + struct SideTable 某个对象所处的 SideTable 表，有三个成员变量：spinlock_t slock、RefcountMap refcnts、weak_table_t weak_table。
  + static StripedMap<SideTable>& SideTables 保存 8/64 张 SideTable，获取某个对象所处的 SideTable：SideTable *table = &SideTables()[obj]。
  
  + 对 weak_entry_t 和 weak_table_t 的哈希数组进行操作。存放 weak 变量和移除 weak 变量、weak 变量置为 nil 等操作。
  
  + objc_loadWeakRetained、objc_loadWeak weak 变量读取。（objc_copyWeak、objc_moveWeak）
  
4. AssociatedObject 底层实现原理。class ObjcAssociation 用于保存关联策略和关联值。ObjectAssociationMap 是 key 是 const void *（用于标识某个关联值的 key），value 是 ObjcAssociation 的哈希表。AssociationsHashMap 是 key 是 DisguisedPtr<objc_object>，value 是 ObjectAssociationMap 的哈希表。AssociationsManager 是 key 是 DisguisedPtr<objc_object>，value 是 ObjectAssociationMap 的哈希表。
5. Category 底层实现原理。概念与数据结构：category_t。追加 attachLists、methodizeClass，先编译的先追加，旧函数向后移动，新函数从头开始追加，所以后编译的 category 会追加到列表的最前面去。+ load 函数执行。
6. TaggedPointer 知识点。





## 参考链接
**参考链接:🔗**
+ [NSCoding](https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSCoding/Description.html#//apple_ref/occ/intf/NSCoding)


1. 音视频处理方向。
2. 编译原理，阅读《程序员的自我修养》。
3. 复习、算法、计算机网络。

## 58同城面试题
1. 简单的自我介绍。
2. 介绍 http 和 https。
3. TCP 和 UDP 的区别。
4. KVC 和 KVO 的原理以及追问 KVO 重写 Setter 函数后原始 Setter 函数会怎么样。
5. VC 的生命周期。
6. viewDidLoad 函数中创建的一个局部 OC 变量什么时候销毁。
7. 怎么区分堆区和栈区。
8. block 的分类。
9. runloop 的工作原理。
10. runtime 的消息发送流程。runtime 的常用场景。
11. UIView 和 CALayer 的关系。
12. CoreAnimation 实现动画。
13. CoreML 的使用。
14. 跨平台的使用。
15. 数据库的使用以及多表连查类似的相关的内容。
16. 视频缓存机制。
17. 解释多线程，线程和队列的关系。
18. iOS 10 前后的推送封装。
19. 断点续传的实现。
20. 逆向有没有了解过。
21. 定时器 dispatch_source 和 NSTimer，NSTimer 为什么精度低。


1. 斐波那契数列算法
2. 二叉树的深度和广度遍历
3. 50000个数中前 5 个大的数
4. 二叉树的非递归前序遍历


1. 同步和异步的区别，以及它们的各自的使用场景。
2. 什么是单例模式？Objective-C 和 Swift 下分别是怎么实现的。

3. 什么是 ARC 以及 ARC 的工作原理，ARC 下会存在内存泄漏吗？
答：ARC 是由编译器和 runtime 协作的结果。ARC 中禁止手动调用 retain/release/retainCount/dealloc(dealloc 可重写，但是不能显示调用) 方法。当我们编译源码时，编译器会分析源码中每个对象的生命周期，然后基于这些对象的生命周期，来添加相应的引用计数操作代码。ARC 中新增了 weak/strong 关键属性关键字。

4. 如何最大限度的保证 TableView 的滑动流畅度。
5. 如何实现横竖屏下的三等分约束。
