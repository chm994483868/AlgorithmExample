# iOS 2021 面试前的准备（精简各知识点方便面试前快速复习使用）

> &emsp;博主前期通读了 Apple 的五份源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)、[libdispatch-1173.40.5](https://opensource.apple.com/tarballs/libdispatch/)、[CF-1151.16](https://opensource.apple.com/tarballs/CF/)、[libmalloc-283.100.6](https://opensource.apple.com/tarballs/libmalloc/)、[libclosure-74](https://opensource.apple.com/source/libclosure/) 基本对 iOS 的大部分底层原理都有了一个基础的认知，然后算法部分的话是专注刷了两遍 《剑指 Offer》（在 IDE 里可以完成默写，完全手写的话可能还需要一些练习）。那么既然是面试肯定免不了要刷题，题目的话就从网络搜集各位大佬面试时的题目以及本人面试时被问到的题目，然后试着从自己的理解上给题目作出解答，如有错误的地方还望大家进行指正。   

## 1. KVC 的工作原理。
&emsp;[iOS《Key-Value Coding Programming Guide》官方文档](https://juejin.cn/post/6915290445069156366) 和 [iOS《Key-Value Coding Programming Guide》官方文档](https://juejin.cn/post/6915290445069156366) 这两篇是 KVC 和 KVO 官方文档的翻译，如果需要的话可以进行详细阅读，下面对它们的原理进行简要总结。

&emsp;Key-Value Coding（键值编码）是由 NSKeyValueCoding 非正式协议启用的一种机制，对象采用这种机制来提供对其属性/成员变量的**间接访问**。当一个对象符合键值编码时，它的所有属性/成员变量可以通过一个简洁、统一的消息传递接口（`setValue:forKey:`）通过字符串参数寻址。这种**间接访问机制补充了实例变量及其相关访问器方法（getter 方法）提供的直接访问**。

&emsp;KVC 在代码实现层面则是在 Foundation 框架下有一个 NSKeyValueCoding.h 文件，其内部定义了多组分类接口，其中包括：@interface NSObject(NSKeyValueCoding)、@interface NSArray<ObjectType>(NSKeyValueCoding)、@interface NSDictionary<KeyType, ObjectType>(NSKeyValueCoding)、@interface NSMutableDictionary<KeyType, ObjectType>(NSKeyValueCoding)、@interface NSOrderedSet<ObjectType>(NSKeyValueCoding)、@interface NSSet<ObjectType>(NSKeyValueCoding)，其中 NSObject 基类已经实现了 NSKeyValueCoding 机制的所有接口，所以我们自己创建的 NSObject 子类都是支持 KVC 的，然后 NSArray、NSDictionary、NSMutableDictionary、NSOrderedSet、NSSet 这些子类则是对 `setValue:forKey:` 和 `valueForKey:` 函数进行重载。例如当对一个 NSArray 对象调用 `setValue:forKey:` 函数时，它内部是对数组中的每个元素调用 `setValue:forKey:` 函数。当对一个 NSArray 对象调用 `valueForKey:` 函数时，它返回一个数组，其中包含在数组的每个元素上调用 `valueForKey:` 的结果。返回的数组将包含 `NSNull` 元素，指代的是数组中某些元素调用 `valueForKey:` 函数返回 nil 的情况。

&emsp;集合运算符（@avg、@count、@max、@min、@sum）数组运算符（@distinctUnionOfObjects、@unionOfObjects、）嵌套运算符（@distinctUnionOfArrays、@unionOfArrays、@distinctUnionOfSets）。

&emsp;非对象类型的属性的包装和解包，如 int/float 包装成 NSNumber，struct（NSPoint、NSRange、NSRect、NSSize） 包装成 NSValue。

&emsp;在给定键参数作为输入的情况下，`valueForKey:` 的默认实现执行以下过程。（在接收 `valueForKey:` 调用的类对象内部进行操作）

1. 在实例中搜索第一个名为 `get<Key>`、`<key>`、`is<Key>` 或 `\_<key>` 的访问器方法。如果找到了，则调用它并继续执行步骤 5 并返回结果。否则继续下一步。（如果想简单描述的话可以把步骤 2 和 3 省略，2 和 3 针对是一对多关系的搜索过程，如 NSArray 和 NSSet 类型属性的搜索过程）

2. 如果找不到简单的访问器方法，在实例中搜索名称与 `countOf<Key>`、`objectIn<Key>AtIndex:`（对应于 NSArray 类定义的原始方法） 和 `<key>AtIndexes:`（对应于 NSArray 的 `objectsAtIndexes:` 方法）模式匹配的方法。
  如果找到其中的第一个以及其他两个中的至少一个，则创建一个响应所有 NSArray 方法的集合代理对象（collection proxy object），并返回该对象。否则，请继续执行步骤 3。
  代理对象随后将接收到的任何 NSArray 消息转换为 `countOf<Key>`、`objectIn<Key>AtIndex:` 和 `<Key>AtIndexes:` 消息的组合，并将其转换为创建它的键值编码兼容对象。如果原始对象还实现了一个名为 `get<Key>:range:` 之类的可选方法，则代理对象也将在适当时使用该方法。实际上，代理对象与键值编码兼容的对象一起工作，允许底层属性的行为就像 NSArray 一样，即使它不是。
  
3. 如果找不到简单的访问器方法或数组访问方法组，请查找名为 `countOf<Key>`、`enumeratorOf<Key>` 和 `memberOf<Key>` 的三重方法。（对应于 NSSet 类定义的原始方法）
  如果找到所有三个方法，请创建一个响应所有 NSSet 方法的集合代理对象，并返回该对象。否则，继续执行步骤 4。
  代理对象随后将接收到的任何 NSSet 消息转换为 `countOf<Key>`、`enumeratorOf<Key>` 和 `memberOf<Key>` 消息的某种组合，以创建它的对象。实际上，代理对象与键值编码兼容对象一起工作，使得基础属性的行为就像 NSSet 一样，即使它不是 NSSet。
  
4. 如果找不到简单的访问器方法或集合访问方法组，并且如果 receiver 的类方法 `accessInstanceVariablesDirectly` 返回 YES，则按该顺序搜索名为 `\_<key>`、`\_is<Key>`、`<key>` 或 `is<Key>` 的实例变量。如果找到，则直接获取实例变量的值并继续执行步骤 5。否则，继续进行步骤 6。

5. 如果检索到的属性值是对象指针，则只需返回结果。
  如果该值是 NSNumber 支持的标量类型，则将其存储在 NSNumber 实例中并返回它。
  如果结果是 NSNumber 不支持的标量类型，则转换为 NSValue 对象并返回该对象。
  
6. 如果所有方法均失败，则调用 `valueForUndefinedKey:`。默认情况下，这会引发一个 NSUndefinedKeyException 异常，但是 NSObject 的子类可以提供特定于键的行为（子类重写 `valueForUndefinedKey:` 函数，那进一步我们自行添加一个 NSObject 分类重写 `valueForUndefinedKey:` 方法呢？）。

&emsp;`setValue:forKey:` 的默认实现，给定 key 和 value 参数作为输入，尝试将名为 key 的属性设置为 value，使用以下过程在接收到调用的对象内部：

1. 按此顺序查找名为 `set<Key>:` 或 `\_set<Key>` 的第一个访问器。如果找到了，则使用 value（或根据需要解包 value 的值）调用它并完成。

2. 如果未找到简单的访问器，并且类方法 `accessInstanceVariablesDirectly` 返回 YES，按该顺序查找名称类似于 `\_<key>`、`\_is<Key>`、`<key>` 或 `is<Key>` 的实例变量。如果找到，则直接使用 value（或根据需要解包 value 的值）设置实例变量并完成操作。

3. 在找不到访问器或实例变量时，调用 `setValue:forUndefinedKey:`。这在默认情况下会引发 NSUndefinedKeyException 异常，但 NSObject 的子类可能会提供键特定的行为。（由子类重写 `setValue:forUndefinedKey:`）

> &emsp;NOTE: 当你使用非对象属性的 nil 值调用其中一个键值编码协议 setter 时，setter 没有明显的常规操作过程可采取。因此，它向接收 setter 调用的对象发送 `setNilValueForKey:` 消息。此方法的默认实现会引发 NSInvalidArgumentException 异常，但子类可能会重写此行为，如处理非对象值中所述，例如设置标记值或提供有意义的默认值。

&emsp;键值编码是高效的，尤其是当你依靠默认实现来完成大部分工作时，但是它确实添加了一个间接级别，该级别比直接的方法调用稍慢。只有当你可以从它提供的灵活性中获益或者允许你的对象参与依赖于它的 Cocoa 技术时，才使用键值编码。

***

## 2. KVO 的工作原理。（追问 KVO 动态生成的新类重写了属性的 Setter 函数后，那原始手动实现的 Setter 函数会被覆盖吗？对对象的某个属性添加观察者后那对象的 isa 指向和 class 函数会发生什么变化？移除观察者后呢？）
&emsp;Key-Value Observing（键值观察）是一种机制，它允许将其他对象的指定属性的更改通知给对象。

> &emsp;KVO （自动键值观察）是通过 isa-swizzling （交换）实现的。基本的流程就是编译器自动为被观察者对象创造一个派生类（此派生类的父类是被观察者对象所属的类），并将被观察者对象的 isa  指向这个派生类（类名是 NSKVONotifying_XXX）。如果用户注册了对此目标对象的某一个属性的观察，那么此派生类会重写这个属性的 setter 方法，并在其中添加进行通知的代码。Objective-C 在发送消息的时候，会通过 isa 指针找到当前对象所属的类对象。而类对象中保存着当前对象可调用的实例方法，因此在向此对象发送消息时候，实际上是发送到了派生类对象的方法。由于编译器对派生类的方法进行了重写，并添加了通知代码，因此会向注册的观察者对象发送通知。注意派生类只重写注册了观察者的属性方法。

```c++
-(void)setValue:(id)obj {
    [self willChangeValueForKey:@"keyPath"];
    
    // 这里内部使用 super 调用，由于当前派生类的 super 正是指向原类，所以不影响原类中自己手动实现的 setter 函数调用（去 58 面试时遇到了这个问题） 
    [super setValue:obj];
    
    [self didChangeValueForKey:@"keyPath"];
}
```

&emsp;如下示例代码中定义的 Student 类，当对其 name 属性注册了观察者后，打印其 class 和 isa 如下：
```c++
@interface Student : NSObject
@property (nonatomic, copy) NSString *name;
@end

// 对 self.student 添加观察者后 class 函数返回的依然是 Student
NSLog(@"🤍🤍 %@", [self.student class]);

// object_getClass 方法返回 isa 指向却是 NSKVONotifying_Student
NSLog(@"🤍🤍 %@", object_getClass(self.student));

// 控制台打印:
🤍🤍 Student
🤍🤍 NSKVONotifying_Student
 
// 然后移除 self.student 的观察者后，object_getClass(self.student) 返回的则是 Student。
```

> &emsp;简而言之，Apple 使用了一种 isa 交换的技术，当 student 被观察后，student 对象的 isa 指针被指向了一个新建的 Student 的子类 NSKVONotifying_Student，且这个子类重写了被观察属性的 setter 方法、class 方法、dealloc 和 \_isKVO 方法，然后使 student 对象的 isa 指针指向这个新建的类，然后事实上 student 变为了NSKVONotifying_Student 的实例对象，执行方法要从这个类的方法列表里找。dealloc 方法：观察者移除后使 class 变回去 Student（通过 isa 指向）, \_isKVO 方法判断被观察者自己是否同时也观察了其他对象。（同时苹果警告我们，通过 isa 获取类的类型是不可靠的，通过 class 方法才能得到正确的类）[用代码探讨 KVC/KVO 的实现原理](https://juejin.cn/post/6844903587898753037)

+ 验证观察者提前释放了且被观察者没有主动移除该观察者，那被观察者的 isa 会不会回归为原类？
  不会回归原类，还是 NSKVONotifying_xxx 类，且此时再向观察者发送通知（observeValueForKeyPath:ofObject:change:context:）会发生野指针访问 crash。
+ 验证 KVO 中编译器派生的新类的父类是不是原类？
  是原类，例如打印 `class_getSuperclass(object_getClass(self.vcTestObjc))`  时可看到 NSKVONotifying_TestObjc 的父类是 TestObjc。
+ 如何手动触发 KVO？
```c++
[self willChangeValueForKey:@"vcTestObjcTWO"];

// 这里我们直接给实例变量赋值，不执行 vcTestObjcTWO 属性的 Setter 函数则会手动触发一次监听通知，
// 如果是使用 self.vcTestObjcTWO 赋值，则会调用 Setter 函数，此时手动加自动便会执行两次监听通知。 
_vcTestObjcTWO = [[TestObjc alloc] init];

[self didChangeValueForKey:@"vcTestObjcTWO"];
```

***

## 3. iOS 中的方法缓存、快速查找、慢速查找流程。
&emsp;首先是 cache_t cache 的位置，它是 objc_class 结构体的第三个成员变量（起始地址偏移 16 个字节），类型是 cache_t 结构体，从数据结构角度及使用方法来看 `cache_t` 的话，它是一个 `SEL`  作为 `Key` ，`SEL + IMP(bucket_t)` 作为 `Value` 的哈希表。
```c++
struct objc_class : objc_object {
// Class ISA; // objc_class 继承自 objc_object，所以其第一个成员变量其实是 isa_t isa 
Class superclass; // 父类指针
cache_t cache; // formerly cache pointer and vtable 以前缓存指针和虚函数表
...
};
```
&emsp;**方法缓存插入的执行过程：** 把指定的 `sel` 和 `imp` 插入到 `cache_t` 中，如果开始是空状态，则首先会初始一个容量为 4 散列数组再进行插入，其它情况插入之前会计算已用的容量占比是否到了临界值 3/4，如果是则首先进行扩容扩大为 2 倍，然后再进行插入操作（哈希函数是直接 sel 和 mask 与操作），如果还没有达到则直接插入，插入操作如果发生了哈希冲突则以开放寻址法进行哈希探测。cache 扩容时为了性能考虑不会把旧的 buckets 数据重新哈希放入新内存中，会把旧的 buckets 放进一个等待释放的数组中，但是也不会立即就释放旧的 bukckts，而是将旧的 buckets 存放到全局的 static bucket_t **garbage_refs 数组中，以便稍后释放，注意这里是稍后释放。因为此时可能其他线程正在进行方法缓存查找。当 garbage_refs 数组的内存容量达到阈值 32*1024 字节时会进行释放旧的 buckets 数据。（_collecting_in_critical 函数内部会判断当前是否有别的线程在查找旧 buckets 数据，如果没有到话才会进行释放旧 buckets 数据）

&emsp;**objc_msgSend 函数** 那么 `objc_msgSend` 是怎么实现的呢？乍看它以为是一个 `C/C++` 函数，但它其实是汇编实现的。
使用汇编的原因，除了 **快速，方法的查找操作是很频繁的，汇编是相对底层的语言更容易被机器识别，节省中间的一些编译过程**  还有一些重要的原因，**用汇编实现，是为了应对不同的 “Calling convention”，把函数调用前的栈和寄存器的参数、状态设置，交给编译器去处理**。

&emsp;objc_msgSend 函数查找 cache 的过程，x0 保存 self，x1 保存 \_cmd，后续的 x2-x7 依次是存放其他参数（超过 7 个参数时存在栈中）。 在 arm64 下首先判断 self 是否小于等于 0，如果是的话判断是 TaggedPointer （TaggedPointer 在 arm64 下，最高位为 1，作为有符号数 < 0）还是 nil，如果是 nil 则跳转到 LReturnZero 把寄存器清 0，如果是 TaggedPointer（从类表中取 Class）  或正常的对象（从 isa 中取 Class，3～36 bit），则首先取得它们所属的类，然后是 CacheLookup 在缓存中查找或进行完整方法查找。缓存查找首先找到从 Class 起始地址偏移 16 字节取得 cache_t cache 成员变量，然后根据传入的 \_cmd 在 buckets 哈希表中进行哈希查找（\_cmd & mask）（开放寻址法），缓存命中时 TailCallCachedImp 内部 br 指令调用 \_cmd 对应的 imp（其他参数都已经在寄存器中存放好）（在缓存表进行哈希查找的过程中有一个细节可展开可不展开，当到达缓存表头后，继续从缓存表尾开始全缓存表扫描，直至重新回到缓存表头。是为了处理缓存被破坏时的情况。）如果缓存未命中的情况下，则都会调用 \_\_objc_msgSend_uncached 内部则是调用 MethodTableLookup（即查询方法列表） 进行方法查找。（即大家常说的慢速查找）

&emsp;缓存未命中时，都会走到 \_\_objc_msgSend_uncached 去处理。\_\_objc_msgSend_uncached 的实现很简单，调用 MethodTableLookup 进行方法查找。MethodTableLookup 的核心则是进行一个 lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER) 的查找，找到 imp 后同样是 TailCallFunctionPointer 调用，下面我们看 lookUpImpOrForward 函数，它是一个 C 函数定义在 objc-runtime-new.mm 文件中。

> + C/C++ 中调用 汇编 ，去查找汇编时，C/C++ 调用的方法需要多加一个下划线
  + 汇编 中调用 C/C++ 方法时，去查找 C/C++ 方法，需要将汇编调用的方法去掉一个下划线

&emsp;当缓存未命中时首先进行的是在当前类中进行慢速查找，如果还是未找到的话，会去父类的缓存中查找，依然未命中的话则是在父类中进行慢速查找。沿着继承链一直重复缓存查找和慢速查找直到根类。在父类中找到的方法会被缓存到当前类的 cache 中。

&emsp;lookUpImpOrForward 函数开始先进行 是否是已知类、类是否实现、是否初始化三个判断，然后是 for 循环沿着类继承链或者元类继承链进行顺序查找，在 curClass 的方法列表（从类的第四个成员变量 class_data_bits_t bits 中取得方法列表）中使用二分查找算法查找方法（findMethodInSortedMethodList），如果找到的话写入 cls 的 cache 中并返回 imp。如果 for 循环结束都没有找到则判断是否进行动态方法解析，即我们熟悉的 resolveInstanceMethod 和 resolveClassMethod。 

&emsp;类的方法列表是 class list_array_tt，它有三种形态：
+ empty
+ a pointer to a single list
+ an array of pointers to lists（当类存在分类时，它的方法列表是这种二维数组的形式。且分类的方法列表排在原类的方法列表前面）

&emsp;最后如果在快速查找、慢速查找、方法解析流程中，均没有找到实现，则使用消息转发，调用汇编函数 \_objc_msgForward_impcache 其内部是跳转至 \_\_objc_msgForward 其内部调用 \_objc_forward_handler，它是一个函数指针，默认指向：`void *_objc_forward_handler = (void*)objc_defaultForwardHandler;`，objc_defaultForwardHandler 内部则是抛出我们见过很多次的 unrecognized selector 错误。
```c++
// Default forward handler halts the process.
__attribute__((noreturn, cold)) void
objc_defaultForwardHandler(id self, SEL sel)
{
    _objc_fatal("%c[%s %s]: unrecognized selector sent to instance %p "
                "(no message forward handler is installed)", 
                class_isMetaClass(object_getClass(self)) ? '+' : '-', 
                object_getClassName(self), sel_getName(sel), self);
}
void *_objc_forward_handler = (void*)objc_defaultForwardHandler;
```

&emsp;参考链接🔗🔗：
+ [iOS 从源码解析Runtime (八)：聚焦cache_t及方法缓存实现相关内容篇(1)](https://juejin.cn/post/6878592460739182599)
+ [iOS 从源码解析Runtime (九)：聚焦cache_t objc-msg-arm64.s解析(2)](https://juejin.cn/post/6880503993798230030)
+ [iOS 从源码解析Runtime (十)：聚焦cache_t objc-msg-arm64.s补充(3)](https://juejin.cn/post/6880774335192432647)
+ [翻译-为什么objc_msgSend必须用汇编实现](http://tutuge.me/2016/06/19/translation-why-objcmsgsend-must-be-written-in-assembly/)
+ [iOS-底层原理 12：消息流程分析之快速查找](https://www.jianshu.com/p/89ab04a91cbc)
+ [iOS-底层原理 13：消息流程分析之慢速查找](https://www.jianshu.com/p/f7d9f6d86145)

***

## 4. 解释 Dynamic Method Resolution 与 Message Forwarding。
&emsp;在 OC 中每个方法调用都是一个发送消息的过程，这是一种在运行时选择方法实现的方式，用面向对象编程的术语来说，方法是动态绑定到消息的。（动态绑定就是沿着对象的 isa 在类的继承体系中查找具体的函数实现的过程）。

&emsp;绕过动态绑定的唯一方法是获取方法的地址并直接调用它，就好像它是一个函数一样。当一个特定的方法将连续执行很多次，并且你希望避免每次执行该方法时的消息传递开销时，这种方法可能非常合适。使用 NSObject 类中定义的方法 methodForSelector: 你可以取得指定类下 selector 对应的方法的指针，然后使用该指针来调用该方法。 methodForSelector: 返回的指针必须仔细转换为适当的函数类型。返回类型和参数类型都应包含在强制类型转换中。如下示例代码调用 setFilled: 方法的过程：
```c++
void (*setter)(id, SEL, BOOL);
int i;
 
setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];
for ( i = 0 ; i < 1000 ; i++ )
    setter(targetList[i], @selector(setFilled:), YES);
```

&emsp;使用 methodForSelector: 规避动态绑定可以节省消息传递所需的大部分时间。但是，仅在重复多次发送特定消息的情况下，这种节省才是可观的，如上面的 for 循环所示。注意 methodForSelector: 由 Cocoa 运行时系统提供；这不是 Objective-C 语言本身的功能。

&emsp;Selector 选择器是用于选择要为对象执行的方法的名称，或者是在编译源代码时替换该名称的唯一标识符。选择器本身不起任何作用。它只是标识一个方法。

&emsp;NSMethodSignature 方法签名，表示方法的返回值和参数的类型信息。可以使用 NSObject 的 methodSignatureForSelector: 实例方法创建 NSMethodSignature 对象。NSMethodSignature 对象是用一个字符数组初始化的 `+ (nullable NSMethodSignature *)signatureWithObjCTypes:(const char *)types;`，该数组表示方法的返回和参数类型的字符串编码。如表示 NSString 实例方法 containsString: 方法签名的字符串是：`c@:@`。（c 是返回类型 BOOL，@ 是 self，: 是 \_cmd，@ 是第一个显示参数 NSString *）

&emsp;NSInvocation 描绘为对象的 Objective-C 消息，即以 NSInvocation 对象描述 Objective-C 消息，用于在对象之间和应用程序之间存储和转发消息。NSInvocation 对象包含 Objective-C 消息的所有元素：目标（target）、选择器（selector）、参数（arguments）和返回值（return value），这些元素中的每一个都可以直接设置，并且在 invoke NSInvocation 对象时会自动设置返回值（`- (void)invoke;` 将 NSInvocation 对象的消息（带有参数）发送到其 `target` 并设置返回值（`setReturnValue:`），必须先设置 NSInvocation 对象的 `target`、`selector` 和参数值（`setArgument:atIndex:`），然后才能调用此方法）。

&emsp;NSInvocation 不支持使用可变数量的参数或 union 参数调用方法，应该使用 invocationWithMethodSignature: 类方法创建 NSInvocation 对象，不应该使用 alloc 和 init 创建 NSInvocation 对象。为了提高效率，新创建的 NSInvocation 对象不保留或复制其参数，也不保留其 target（target 是 assign 修饰的 id 类型的属性：`@property (nullable, assign) id target;`）、复制 C 字符串或复制任何关联的 blocks。如果要缓存 NSInvocation 对象，则应该指示该对象保留其参数（调用 retainArguments 函数），因为这些参数可能会在调用之前释放。NSTimer 对象总是指示它们的调用保留它们的参数，因为在计时器触发之前通常有一个延迟。

&emsp;`BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)` 向具有给定名称和实现的类中添加新方法。Return Value: 如果成功添加了方法，则为 YES，否则为 NO（例如，该类已经包含具有该名称的方法实现时也会返回 NO）。要更改现有的实现，请使用 `IMP method_setImplementation(Method m, IMP imp);` 设置方法的新实现，返回值是该方法的旧实现。如下示例：
```c++
// Objective-C 方法只是一个 C 函数，它至少接受两个参数 self 和 \_cmd。
void myMethodIMP(id self, SEL _cmd) {
    // implementation ....
}

// 可以像这样将方法动态添加到类中
class_addMethod([self class], @selector(resolveThisMethodDynamically), (IMP)myMethodIMP, "v@:");
```

&emsp;resolveInstanceMethod: 动态的为实例方法的给定选择器（sel）提供实现。resolveClassMethod: 动态的为类方法的给定选择器（sel）提供实现。如下示例：
```c++
+ (BOOL)resolveInstanceMethod:(SEL)aSEL {
    if (aSEL == @selector(resolveThisMethodDynamically)) {
          class_addMethod([self class], aSEL, (IMP)dynamicMethodIMP, "v@:");
          return YES;
    }
    
    return [super resolveInstanceMethod:aSel];
}
```

&emsp;forwardingTargetForSelector: 返回未识别消息应首先指向的对象。
```c++
- (id)forwardingTargetForSelector:(SEL)aSelector OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);
```

&emsp;objc-781 下 NSObject  类的 forwardingTargetForSelector 函数的默认实现，是直接返回 nil。
```c++
+ (id)forwardingTargetForSelector:(SEL)sel {
    return nil;
}

- (id)forwardingTargetForSelector:(SEL)sel {
    return nil;
}
```

&emsp;如果你在非根类（非 NSObject）中实现此方法，如果你的类对于给定的选择器没有要返回的内容，那么你应该返回调用 super 实现的结果（return [super forwardingTargetForSelector:aSelector];）。

&emsp;这种方法使对象有机会在更昂贵的 forwardInvocation: 机制接管之前重定向发送给它的未知消息。当你只想将消息重定向到另一个对象时，这非常有用，并且可以比常规转发快一个数量级。如果转发的目标是捕获 NSInvocation，或者在转发过程中操纵参数或返回值，那么它就没有用了。

&emsp;methodSignatureForSelector: 返回一个 NSMethodSignature 对象，该对象包含由给定选择器标识的方法的描述。（也可以根据自己的需要返回有别与 aSelector 之外的  NSMethodSignature）
```c++
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE("");
```

&emsp;forwardInvocation: 被子类重写以将消息转发到其他对象。
```c++
- (void)forwardInvocation:(NSInvocation *)anInvocation OBJC_SWIFT_UNAVAILABLE("");
```

&emsp;当一个对象被发送一条没有相应方法（实现）的消息时，运行时系统给接收者一个机会将消息委托给另一个接收者。它通过创建表示消息的 NSInvocation 对象并向接收方发送 forwardInvocation: 包含此 NSInvocation 对象作为参数的消息来代理消息。然后，接收方的 forwardInvocation: 方法可以选择将消息转发到另一个对象。（如果该对象也不能响应消息，它也将有机会转发消息。）

> &emsp;Important: 要响应对象本身无法识别的方法，除了 forwardInvocation: 之外，还必须重写  methodSignatureForSelector:。转发消息的机制使用从 methodSignatureForSelector: 获取的信息（NSMethodSignature 对象）来创建要转发的 NSInvocation 对象。重写方法必须为给定的选择器提供适当的方法签名，方法可以是预先制定一个方法签名，也可以是向另一个对象请求一个方法签名。

&emsp;forwardInvocation: 方法的实现有两个任务：
+ 定位一个对象，该对象可以响应在 `anInvocation` 中编码的消息。对于所有消息，此对象不必相同。
+ 使用 `anInvocation` 将消息发送到该对象。调用将保存结果，运行时系统将提取该结果并将其传递给原始发送者。

&emsp;在一个简单的情况下，对象只将消息转发到一个目的地（如下面示例中假设的 friend 实例变量），forwardInvocation: 方法可以如下所示：
```c++
- (void)forwardInvocation:(NSInvocation *)invocation {
    SEL aSelector = [invocation selector];
 
    if ([friend respondsToSelector:aSelector])
        [invocation invokeWithTarget:friend];
    else
        [super forwardInvocation:invocation];
}
```

&emsp;forwardInvocation: 方法的实现可以做的不仅仅是转发消息。forwardInvocation: 例如，可以用于合并响应各种不同消息的代码，从而避免了为每个选择器编写单独方法的必要性。forwardInvocation: 方法可能还会在对给定消息的响应中包含其他几个对象，而不是只将其转发给一个对象。

&emsp;NSObject 的 forwardInvocation: 实现只是调用 doesNotRecognizeSelector: 方法；它不转发任何消息。因此，如果选择不实现 forwardInvocation:，则向对象发送无法识别的消息将引发异常。

&emsp;objc-781 下 NSObject 类的 forwardInvocation: 函数的默认实现:
```c++
+ (void)forwardInvocation:(NSInvocation *)invocation {
    [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)];
}

- (void)forwardInvocation:(NSInvocation *)invocation {
    [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)];
}
```

&emsp;Dynamic Method Resolution（动态方法解析）: 即实现 `resolveInstanceMethod:` 和 `resolveClassMethod:` 方法，分别为实例和类方法的给定选择器动态提供实现。&emsp;Message Forwarding（消息转发）和 Dynamic Method Resolution（动态方法解析）在很大程度上是正交的，类有机会在转发机制启动之前动态解析方法。如果调用了 `respondsToSelector:` 或 `instancesRespondToSelector:`，则动态方法解析器将有机会首先为选择器提供 IMP。如果你实现 `resolveInstanceMethod:` 但希望特定的选择器实际通过转发机制转发，那么你需要为这些选择器返回 NO。

&emsp;如果 Dynamic Method Resolution（动态方法解析）无法补救时，继续走下一个流程：Fast forwarding 快速转发阶段（如果可以的话返回一个备用响应对象 forwardingTargetForSelector: ）和 Normal forwarding 常规转发阶段（完整的消息转发 methodSignatureForSelector:  和 forwardInvocation:）。

&emsp;forwardInvocation: 它是动态的而不是静态的。它的工作方式如下：当对象由于没有与消息中的选择器匹配的方法而无法响应消息时，运行时系统会通过向其发送 forwardInvocation: 消息来通知对象，其中 NSInvocation 对象作为其唯一参数，NSInvocation 对象将封装原始消息及其传递的参数。每个对象都从 NSObject 类继承了 forwardInvocation: 方法。但是，该方法的 NSObject 版本仅调用 dosNotRecognizeSelector:。通过覆盖 NSObject 的版本并实现自己的版本，你可以利用 forwardInvocation: 消息提供的机会将消息转发给其他对象。

&emsp;forwardInvocation: 方法可以充当未识别消息的分发中心，将它们分发给不同的接收者。或者它可以是一个中转站，将所有消息发送到同一个目的地。它可以将一条消息转换成另一条消息，或者简单地 “吞下（swallow）” 一些消息，这样就没有响应也没有错误。forwardInvocation: 方法还可以将多个消息合并到单个响应中。forwardInvocation: 做什么取决于实现者。然而，它提供了在转发链中链接对象的机会，为程序设计开辟了可能性。

&emsp;转发提供了你通常希望从多重继承中获得的大部分功能。然而，两者之间有一个重要的区别：多重继承在单个对象中结合了不同的功能。它趋向于大的、多方面的对象。另一方面，转发将不同的责任分配给不同的对象。它将问题分解为更小的对象，但以对消息发送者透明的方式关联这些对象。尽管转发模仿继承，但 NSObject 类从不混淆两者。`respondsToSelector:` 和 `isKindOfClass:` 等方法只查看继承层次结构，而不查看转发链。

&emsp;如果使用转发来设置代理对象或扩展类的功能，则转发机制应该与继承一样透明。如果你希望你的对象像他们真正继承了转发消息的对象的行为一样工作，则需要重新实现 `responsToSelector:` 和 `isKindOfClass:` 方法以包括你的转发算法：
```c++
- (BOOL)respondsToSelector:(SEL)aSelector {
    if ( [super respondsToSelector:aSelector] )
        return YES;
    else {
        /* Here, test whether the aSelector message can     *
         * be forwarded to another object and whether that  *
         * object can respond to it. Return YES if it can.  */
         
        // 在这里，测试 aSelector 消息是否可以转发到另一个对象以及该对象是否可以响应。如果可以，则返回 YES。
        
    }
    return NO;
}
```
&emsp;如果对象转发其收到的任何远程消息，则它应具有 `methodSignatureForSelector:` 的版本， 该函数可以返回对最终响应所转发消息的方法的准确描述。例如，如果对象能够将消息转发到其代理，则可以实现 `methodSignatureForSelector:` 如下：
```c++
- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector{
    NSMethodSignature* signature = [super methodSignatureForSelector:selector];
    if (!signature) {
       signature = [surrogate methodSignatureForSelector:selector];
    }
    return signature;
}
```

&emsp;参考链接🔗🔗：
+ [译】iOS Dynamic Method Resolution与Message Forwarding 官方文档](https://juejin.cn/post/6919050932512620552#heading-37)

***

## 5. 什么是 ARC 以及 ARC 的工作原理，ARC 下会存在内存泄漏吗？




***

## 5. UIView 与 CALayer  CoreAnimation 





1. iOS 屏幕成像原理（离屏渲染 Off-screen Rendered）。
2. atomic、nonatomic、strong（retain）、weak（unsafe_unretained）、assign 属性修饰符的工作原理。（\_\_strong、\_\_weak、\_\_unsafe_unretained）
3. weak 底层实现原理。
  + DisguisedPtr<objc_object> DisguisedPtr<objc_object *> 伪装指针，把地址变为整数保存。
  + typedef DisguisedPtr<objc_object *> weak_referrer_t; weak 变量的地址，即一个指针的指针。
  + struct weak_entry_t 保存某个对象的所有 weak 变量地址的哈希表。
  + struct weak_table_t 保存对象和其 weak_entry_t 的哈希表。
  + struct SideTable 某个对象所处的 SideTable 表，有三个成员变量：spinlock_t slock、RefcountMap refcnts、weak_table_t weak_table。
  + static StripedMap<SideTable>& SideTables 保存 8/64 张 SideTable，获取某个对象所处的 SideTable：SideTable *table = &SideTables()[obj]。
  
  + 对 weak_entry_t 和 weak_table_t 的哈希数组进行操作。存放 weak 变量和移除 weak 变量、weak 变量置为 nil 等操作。
  
  + objc_loadWeakRetained、objc_loadWeak weak 变量读取。（objc_copyWeak、objc_moveWeak）
  
4. AssociatedObject 底层实现原理。class ObjcAssociation 用于保存关联策略和关联值。ObjectAssociationMap 是 key 是 const void *（用于标识某个关联值的 key），value 是 ObjcAssociation 的哈希表。AssociationsHashMap 是 key 是 DisguisedPtr<objc_object>，value 是 ObjectAssociationMap 的哈希表。AssociationsManager 是 key 是 DisguisedPtr<objc_object>，value 是 ObjectAssociationMap 的哈希表。
5. Category 底层实现原理。概念与数据结构：category_t。追加 attachLists、methodizeClass，先编译的先追加，旧函数向后移动，新函数从头开始追加，所以后编译的 category 会追加到列表的最前面去。+ load 函数执行。
6. TaggedPointer 知识点。





## 参考链接
**参考链接:🔗**
+ [NSCoding](https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSCoding/Description.html#//apple_ref/occ/intf/NSCoding)


1. 音视频处理方向。
2. 编译原理，阅读《程序员的自我修养》。
3. 复习、算法、计算机网络。

## 58同城面试题
1. 简单的自我介绍。
2. 介绍 http 和 https。
3. TCP 和 UDP 的区别。
4. KVC 和 KVO 的原理以及追问 KVO 重写 Setter 函数后原始 Setter 函数会怎么样。
5. VC 的生命周期。
6. viewDidLoad 函数中创建的一个局部 OC 变量什么时候销毁。
7. 怎么区分堆区和栈区。
8. block 的分类。
9. runloop 的工作原理。
10. runtime 的消息发送流程。runtime 的常用场景。
11. UIView 和 CALayer 的关系。
12. CoreAnimation 实现动画。
13. CoreML 的使用。
14. 跨平台的使用。
15. 数据库的使用以及多表连查类似的相关的内容。
16. 视频缓存机制。
17. 解释多线程，线程和队列的关系。
18. iOS 10 前后的推送封装。
19. 断点续传的实现。
20. 逆向有没有了解过。
21. 定时器 dispatch_source 和 NSTimer，NSTimer 为什么精度低。


1. 斐波那契数列算法
2. 二叉树的深度和广度遍历
3. 50000个数中前 5 个大的数
4. 二叉树的非递归前序遍历


1. 同步和异步的区别，以及它们的各自的使用场景。
2. 什么是单例模式？Objective-C 和 Swift 下分别是怎么实现的。

3. 什么是 ARC 以及 ARC 的工作原理，ARC 下会存在内存泄漏吗？
答：ARC 是由编译器和 runtime 协作的结果。ARC 中禁止手动调用 retain/release/retainCount/dealloc(dealloc 可重写，但是不能显示调用) 方法。当我们编译源码时，编译器会分析源码中每个对象的生命周期，然后基于这些对象的生命周期，来添加相应的引用计数操作代码。ARC 中新增了 weak/strong 关键属性关键字。

4. 如何最大限度的保证 TableView 的滑动流畅度。
5. 如何实现横竖屏下的三等分约束。
