# iOS 2021 面试前的准备（总结各知识点方便面试前快速复习使用）（二）

> &emsp;博主前期通读了 Apple 的五份源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)、[libdispatch-1173.40.5](https://opensource.apple.com/tarballs/libdispatch/)、[CF-1151.16](https://opensource.apple.com/tarballs/CF/)、[libmalloc-283.100.6](https://opensource.apple.com/tarballs/libmalloc/)、[libclosure-74](https://opensource.apple.com/source/libclosure/) 基本对 iOS 的大部分底层原理都有了一个基础的认知，然后算法部分的话是专注刷了两遍 《剑指 Offer》（在 IDE 里可以完成默写，完全手写的话可能还需要一些练习）。那么既然是面试肯定免不了要刷题，题目的话就从网络搜集各位大佬面试时的题目以及本人面试时被问到的题目，然后试着从自己的理解上给题目作出解答，如有错误的地方还望大家进行指正。   

## 11. 进程和线程的理解。
&emsp;


&emsp;参考链接🔗🔗：
+ [iOS 多线程知识体系构建(一)：基本概念篇](https://juejin.cn/post/6894166184687009799)

***

## iOS 中的线程锁的介绍。
&emsp;锁是常用的同步工具，一段代码段在同一个时间只能允许被有限个线程访问。比如一个线程 A 进入需要保护的代码之前添加简单的互斥锁，另一个线程 B 就无法访问这段保护代码了，只有等待前一个线程 A 执行完被保护的代码后解锁，B 线程才能访问被保护的代码段。

&emsp;iOS 开发中使用到的锁，包括 spinlock_t、os_unfair_lock、pthread_mutex_t、NSLock、NSRecursiveLock、NSCondition、NSConditionLock、@synchronized、dispatch_semaphore、pthread_rwlock_t。

&emsp;OSSpinLock 自旋锁，也只有加锁、解锁和尝试加锁三个方法。和 NSLock 不同的是 NSLock 请求加锁失败的话，会先轮询，但一秒后便会使线程进入 waiting 状态，等待唤醒。而 OSSpinLock 会一直轮询，等待时会消耗大量 CPU 资源，不适用于较长时间的任务。

> &emsp;OSSpinLock 存在线程安全问题，它可能导致优先级反转问题，目前我们在任何情况下都不应该再使用它，我们可以使用 apple 在 iOS 10.0 后推出的 os_unfair_lock（iOS 10 以后 OSSpinLock 内部是使用 os_unfair_lock 实现的）。**'OSSpinLock' is deprecated: first deprecated in iOS 10.0 - Use os_unfair_lock() from <os/lock.h> instead**

&emsp;`OSSpinLock lock = OS_SPINLOCK_INIT;` 初始化锁，`OSSpinLockLock(&lock);` 获得锁（加锁），尽管锁定操作旋转，（当加锁失败时会一直处于等待状态，一直到获取到锁为止，获取到锁之前会一直阻塞当前线程）它采用各种策略来支持如果加锁成功，则关闭旋转。`OSSpinLockUnlock(&lock);` 解锁，`OSSpinLockTry(&lock);` 尝试加锁，`bool` 类型的返回值表示是否加锁成功，即使加锁失败也不会阻塞线程。如果锁已经被另一个线程所持有则返回 false，否则返回 true 表示加锁成功。

&emsp;自旋锁 OSSpinLock 不是一个线程安全的锁，等待锁的线程会处于忙等（`busy-wait`）状态，一直占用着 `CPU` 资源。（类似一个 `while(1)` 循环一样，不停的查询锁的状态，注意区分 run loop 机制，同样是阻塞，但是 run loop 是类似休眠的阻塞，不会耗费 CPU 资源，自旋锁的这种忙等机制使它相比其它锁效率更高，毕竟没有 **唤醒-休眠** 这些类似操作，从而能更快的处理事情。）自旋锁目前已经被废弃了，它可能会导致优先级反转。

&emsp;例如 `A/B` 两个线程，`A` 的优先级大于 `B` 的，我们的本意是 `A` 的任务优先执行，但是使用 `OSSpinLock` 后，如果是 `B` 优先访问了共享资源获得了锁并加锁，而 `A` 线程再去访问共享资源的时候锁就会处于忙等状态，由于 `A` 的优先级高它会一直占用 `CPU` 资源不会让出时间片，这样 `B` 一直不能获得 `CPU` 资源去执行任务，导致无法完成。

> &emsp;《不再安全的 OSSpinLock》原文: 新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。
具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。
苹果工程师 Greg Parker 提到，对于这个问题，一种解决方案是用 truly unbounded backoff 算法，这能避免 livelock 问题，但如果系统负载高时，它仍有可能将高优先级的线程阻塞数十秒之久；另一种方案是使用 handoff lock 算法，这也是 libobjc 目前正在使用的。锁的持有者会把线程 ID 保存到锁内部，锁的等待者会临时贡献出它的优先级来避免优先级反转的问题。理论上这种模式会在比较复杂的多锁条件下产生问题，但实践上目前还一切都好。
libobjc 里用的是 Mach 内核的 thread_switch() 然后传递了一个 mach thread port 来避免优先级反转，另外它还用了一个私有的参数选项，所以开发者无法自己实现这个锁。另一方面，由于二进制兼容问题，OSSpinLock 也不能有改动。
最终的结论就是，除非开发者能保证访问锁的线程全部都处于同一优先级，否则 iOS 系统中所有类型的自旋锁都不能再使用了。-[《不再安全的 OSSpinLock》](https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/)

&emsp;os_unfair_lock 设计宗旨是用于替换 OSSpinLock，从 iOS 10 之后开始支持，跟 OSSpinLock 不同，等待 os_unfair_lock 的线程会处于休眠状态（类似 run loop 那样），不是忙等（busy-wait）。

```c++
// os_unfair_lock 是一个结构体
typedef struct os_unfair_lock_s {

uint32_t _os_unfair_lock_opaque;

} os_unfair_lock, *os_unfair_lock_t;
```
1. os_unfair_lock 是一个低等级锁。一些高等级的锁才应该是我们日常开发中的首选。
2. 必须使用加锁时的同一个线程来进行解锁，尝试使用不同的线程来解锁将导致断言中止进程。（ os_unfair_lock_assert_owner 函数判断当前线程是否是 os_unfair_lock 的所有者，否则触发断言。）
3. 锁里面包含线程所有权信息来解决优先级反转问题。
4. 不能通过共享或多重映射内存从多个进程或线程访问此锁，锁的实现依赖于锁值的地址和所属进程。
5. 必须使用 OS_UNFAIR_LOCK_INIT 进行初始化。

&emsp;pthread_mutex_t 是 C 语言下多线程互斥锁的方式，是跨平台使用的锁，等待锁的线程会处于休眠状态，可根据不同的属性配置把 pthread_mutex_t 初始化为不同类型的锁，例如：互斥锁、递归锁、条件锁。当使用递归锁时，允许同一个线程重复进行加锁，另一个线程访问时就会等待，这样可以保证多线程时访问共用资源的安全性。
```c++
PTHREAD_MUTEX_NORMAL // 缺省类型，也就是普通类型，当一个线程加锁后，其余请求锁的线程将形成一个队列，并在解锁后先进先出原则获得锁。
PTHREAD_MUTEX_ERRORCHECK // 检错锁，如果同一个线程请求同一个锁，则返回 EDEADLK，否则与普通锁类型动作相同。这样就保证当不允许多次加锁时不会出现嵌套情况下的死锁
PTHREAD_MUTEX_RECURSIVE // 递归锁，允许同一个线程对同一锁成功获得多次，并通过多次 unlock 解锁。
PTHREAD_MUTEX_DEFAULT // 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争，没有等待队列。
```

&emsp;`pthread_mutex_trylock` 和 `trylock` 不同，`trylock` 返回的是 `YES` 和 `NO`，`pthread_mutex_trylock` 加锁成功返回的是 `0`，失败返回的是错误提示码。

&emsp;NSLock 继承自 NSObject 并遵循 NSLocking 协议，lock 方法加锁，unlock 方法解锁，tryLock 尝试并加锁，如果返回 true 表示加锁成功，返回 false 表示加锁失败，谨记返回的 BOOL 表示加锁动作的成功或失败，并不是能不能加锁，即使加锁失败也会不会阻塞当前线程。lockBeforeDate: 是在指定的 Date 之前尝试加锁，如果在指定的时间之前都不能加锁，则返回 NO，且会阻塞当前线程。大概可以使用在：先预估上一个临界区的代码执行完毕需要多少时间，然后在这个时间之后为另一个代码段来加锁。

1. 基于 `mutex` 基本锁的封装，更加面向对象，等待锁的线程会处于休眠状态。
2. 遵守 `NSLocking` 协议，`NSLocking` 协议中仅有两个方法 `-(void)lock` 和 `-(void)unlock`。
3. 可能会用到的方法: 
  1. 初始化跟其他 `OC` 对象一样，直接进行 `alloc` 和 `init` 操作。
  2. `-(void)lock;` 加锁。
  3. `-(void)unlock;` 解锁。
  4. `-(BOOL)tryLock;` 尝试加锁。
  5. `-(BOOL)lockBeforeDate:(NSDate *)limit;` 在某一个时间点之前等待加锁。
4. 在当前线程连续调用 `[self.lock lock]` 加锁会导致当前线程死锁。
5. 在主线程没有获取 `Lock` 的情况下和在获取 `Lock` 的情况下，连续两次 ` [self.lock unlock]` 都不会发生异常。（其他的锁可能连续解锁的情况下会导致 `crash`，还没有来的及测试）
6. 同时子线程死锁会导致 `ViewController` 不释放。

&emsp;一个线程在加锁的时候，其余请求锁的的线程将形成一个等待队列，按先进先出原则，这个结果可以通过修改线程优先级进行测试得出。

&emsp;NSRecursiveLock 是递归锁，和 NSLock 的区别在于，它可以在同一个线程中重复加锁也不会导致死锁。NSRecursiveLock 会记录加锁和解锁的次数，当二者次数相等时，此线程才会释放锁，其它线程才可以加锁成功。

1. 同 `NSLock` 一样，也是基于 `mutex` 的封装，不过是基于 `mutex` 递归锁的封装，所以这是一个递归锁。
2. 遵守 `NSLocking` 协议，`NSLocking` 协议中仅有两个方法 `-(void)lock` 和 `-(void)unlock`。
3. 可能会用到的方法: 
  1. 继承自 NSObject，所以初始化跟其他 OC 对象一样，直接进行 alloc 和 init 操作。
  2. `-(void)lock;` 加锁
  3. `-(void)unlock;` 解锁
  4. `-(BOOL)tryLock;` 尝试加锁
  5. `-(BOOL)lockBeforeDate:(NSDate *)limit;` 在某一个时间点之前等待加锁。
4. 递归锁是可以在同一线程连续调用 `lock` 不会直接导致阻塞死锁，但是依然要执行相等次数的 `unlock`。不然异步线程再获取该递归锁会导致该异步线程阻塞死锁。
5. 递归锁允许同一线程多次加锁，不同线程进入加锁入口会处于等待状态，需要等待上一个线程解锁完成才能进入加锁状态。

&emsp;NSCondition 的对象实际上作为一个锁和一个线程检查器，锁上之后其它线程也能上锁，而之后可以根据条件决定是否继续运行线程，即线程是否要进入 waiting 状态，经测试，NSCondition 并不会像上文的那些锁一样，先轮询，而是直接进入 waiting 状态，当其它线程中的该锁执行 signal 或者 broadcast 方法时，线程被唤醒，继续运行之后的方法。也就是使用 NSCondition 的模型为: 1. 锁定条件对象。2. 测试是否可以安全的履行接下来的任务。如果布尔值为假，调用条件对象的 wait 或者 waitUntilDate: 方法来阻塞线程。再从这些方法返回，则转到步骤 2 重新测试你的布尔值。（继续等待信号和重新测试，直到可以安全的履行接下来的任务，waitUntilDate: 方法有个等待时间限制，指定的时间到了，则返回 NO，继续运行接下来的任务。而等待信号，既线程执行 [lock signal] 发送的信号。其中 signal 和 broadcast 方法的区别在于，signal 只是一个信号量，只能唤醒一个等待的线程，想唤醒多个就得**多次调用**，而 broadcast 可以唤醒所有在等待的线程，如果没有等待的线程，这两个方法都没有作用。）

1. 基于 `mutex` 基础锁和 `cont` 条件的封装，所以它是互斥锁且自带条件，等待锁的线程休眠。
2. 遵守 `NSLocking` 协议，`NSLocking` 协议中仅有两个方法 `-(void)lock` 和 `-(void)unlock`。
3. 可能会用到的方法
  1. 初始化跟其它 OC 对象一样，直接进行 `alloc` 和 `init` 操作。
  2. `-(void)lock;` 加锁
  3. `-(void)unlock;` 解锁
  4. `-(BOOL)tryLock;` 尝试加锁
  5. `-(BOOL)lockBeforeDate:(NSDate *)limit;` 在某一个时间点之前等待加锁
  6. `-(void)wait;` 等待条件（进入休眠的同时放开锁，被唤醒的同时再次加锁）
  7. `-(void)signal;` 发送信号激活等待该条件的线程，切记线程收到后是从 wait 状态开始的
  8. `- (void)broadcast;` 发送广播信号激活等待该条件的所有线程，切记线程收到后是从 wait 状态开始的

&emsp;NSConditionLock 和 NSLock 类似，同样是继承自 NSObject 和遵循 NSLocking 协议，加解锁 try 等方法都类似，只是多了一个 condition 属性，以及每个操作都多了一个关于 condition 属性的方法，例如 tryLock 和 tryLockWhenCondition:，NSConditionLock 可以称为条件锁。只有 condition 参数与初始化的时候相等或者上次解锁后设置的 condition 相等，lock 才能正确的进行加锁操作。unlockWithCondition: 并不是当 condition 符合条件时才解锁，而是解锁之后，修改 condition 的值为入参，当使用 unlock 解锁时， condition 的值保持不变。如果初始化用 init，则 condition 默认值为 0。lockWhenCondition: 和 lock 方法类似，加锁失败会阻塞当前线程，一直等下去，直到能加锁成功。tryLockWhenCondition: 和 tryLock 类似，表示尝试加锁，即使加锁失败也不会阻塞当前线程，但是同时满足 lock 是空闲状态并且 condition 符合条件才能尝试加锁成功。从上面看出，NSConditionLock 还可以实现任务之间的依赖。

&emsp;@synchronized(object) 指令使用的 object 为该锁的唯一标识，只有当标识相同时，才满足互斥，所以如果线程 2 中的 @synchronized(self) 改为 @synchronized(self.view)，则线程 2 就不会被阻塞，@synchronized 指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized 块会隐式的添加一个异常处理例程来保护代码，**该处理例程会在异常抛出的时候自动释放互斥锁**。@synchronized 还有一个好处就是不用担心忘记解锁了。如果在 @synchronized(object) {} 内部 object 被释放或被设为 nil，从测试结果来看，不会产生问题，但如果 object 一开始就是 nil，则失去了加锁的功能。不过虽然 nil 不行，但是 [NSNull null] 是可以的。

&emsp;`objc4-750` 版本之前（`iOS 12` 之前）`@synchronized` 是一个基于 `pthread_mutex_t` 封装的递归锁，之后实现则发生了改变，底层的封装变为了 `os_unfair_lock`。

&emsp;dispatch_semaphore 是 GCD 用来同步的一种方式，与他相关的只有三个函数，一个是创建信号量，一个是等待信号量，一个是发送信号。
dispatch_semaphore 和 NSCondition 类似，都是一种基于信号的同步方式，但 NSCondition 信号只能发送，不能保存（如果没有线程在等待，则发送的信号会失效）。而 dispatch_semaphore 能保存发送的信号。dispatch_semaphore 的核心是 dispatch_semaphore_t 类型的信号量。

&emsp;dispatch_semaphore_create(1) 方法可以创建一个 dispatch_semaphore_t 类型的信号量，设定信号量的初始化值为 1。注意，这里的传入参数必须大于等于 0，否则 dispatch_semaphore 会返回 NULL。

&emsp;dispatch_semaphore_wait(signal, overTime) 方法会判断 signal 的信号值是否大于 0，大于 0 不会阻塞线程，消耗掉一个信号，执行后续任务。如果信号值为 0，该线程会和 NSCondition 一样直接进入 waiting 状态，等待其他线程发送信号唤醒线程去执行后续任务，或者当 overTime 时限到了，也会执行后续任务。

&emsp;dispatch_semaphore_signal(signal) 发送信号，如果没有等待的线程调用信号，则使 signal 信号值加 1（做到对信号的保存）。一个 dispatch_semaphore_wait(signal, overTime) 方法会去对应一个 dispatch_semaphore_signal(signal) 看起来像 NSLock 的 lock 和 unlock，其实可以这样理解，区别只在于有信号量这个参数，lock unlock 只能同一时间，一个线程访问被保护的临界区，而如果 dispatcch_semaphore 的信号量初始值为 x，则可以有 x 个线程同时访问被保护的临界区。

1. 本来是用于控制线程的最大并发数量，我们将并发数量设置为 `1` 也可以认为是加锁的功能。
2. 可能会用到的方法：
  1. 初始化 `dispatch_semaphore_create()` 传入的值为最大并发数量，设置为 `1` 则达到加锁效果。
  2. 判断信号量的值 `dispatch_semaphore_wait()` 如果大于 `0`，则可以继续往下执行（同时信号量的值减去 `1`），如果信号量的值为 `0`，则线程进入休眠状态等待（此方法的第二个参数就是设置要等多久，一般是使用永久 `DISPATCH_TIME_FOREVER`）。
  3. 释放信号量 `dispatch_semaphore_signal()` 同时使信号量的值加上 `1`。

&emsp;pthread_rwlock_t 读写锁，首先引入一个问题：“如何实现一个多读单写的模型？”，需求如下:
+ 同时可以有多个线程读取。
+ 同时只能有一个线程写入。
+ 同时只能执行读取或者写入的一种。

&emsp;首先想到的就是我们的 `pthread_rwlock_t`。
1. 读取加锁可以同时多个线程进行，写入同时只能一个线程进行，等待的线程处于休眠状态。
2. 可能会用到的方法：
  1. `pthread_rwlock_init()` 初始化一个读写锁
  
  2. `pthread_rwlock_rdlock()` 读写锁的读取加锁
  3. `pthread_rwlock_wrlock()` 读写锁的写入加锁
  
  4. `pthread_rwlock_unlock()` 解锁
  5. `pthread_rwlock_destroy()` 销毁锁

&emsp;dispatch_barrier_async 实现多读单写。
1. 传入的并发队列必须是 `dispatch_queue_create()` 方式手动创建的，如果传入串行队列或者通过 `dispatch_get_global_queue()` 方式获取一个全局并发队列，则 `dispatch_barrier_async` 的作用就跟 `dispatch_async` 变的一样了。
2. 可能会用到的方法：
  1. `dispatch_queue_create()` 创建并发队列
  2. `dispatch_barrier_async()` 异步栅栏

&emsp;锁粗略的效率排序（不同的锁可能更擅长不同的场景）
1. `os_unfair_lock` (iOS 10 之后)
2. `OSSpinLock` (iOS 10 之前)
3. `dispatch_semaphore` (iOS 版本兼容性好)
4. `pthread_mutex_t` (iOS 版本兼容性好)
5. `NSLock` (基于 pthread_mutex_t 封装)
6. `NSCondition` (基于 pthread_mutex_t 封装)
7. `pthread_mutex_t(recursive)` 是递归锁的优先推荐
8. `NSRecursiveLock` (基于 pthread_mutex_t 封装)
9. `NSConditionLock` (基于 NSCondition 封装)
10. `@synchronized`
  1. `iOS 12` 之前基于 `pthread_mutex_t` 封装
  2. `iOS 12` 之后基于 `os_unfair_lock` 封装（iOS 12 之后它的效率应该不是最低，应该排行在 3/4 左右）
  
&emsp;自旋锁和互斥锁怎么取舍选择，其实这个问题已经没有什么意义，因为自旋锁 OSSpinLock 在 iOS 10 之后已经废弃了，而它的替换方案 os_unfair_lock 是互斥锁，但是我们仍然做一下对比:
**自旋锁:**
+ 预计线程需要等待的时间较短
+ 多核处理器
+ CPU 的资源不紧张
**互斥锁:**
+ 预计线程需要等待的时间较长
+ 单核处理器
+ 临界区（加锁解锁之间的部分）有 I/O 操作（即需要等待的时间较长时）

## 12. 什么是 ARC 以及 ARC 的工作原理，ARC 下会存在内存泄漏吗？

***

## 13. UIView 与 CALayer  CoreAnimation 

***
