#  iOS 2021 面试前的准备（总结各知识点方便面试前快速复习使用）（八）

## 64. extension 和 cateogry 区别。
1. extension 可以添加成员变量，category 不能添加成员变量。运行时加载类到内存以后，才会加载分类，这时类的内存布局已经确定（编译器还会对成员变量顺序做出优化，保证遵循内存对齐原则下类占用内存容量最少），如果再去添加成员变量就会破坏类的内存布局。各个成员变量的访问地址是在编译时确定的，每个成员变量的地址偏移都是固定的（相对于类的起始地址的内存偏移（硬编码））。
2. extension 在编译期决议（就确定了是类的一部分），category 在运行期决议。extension 在编译期和头文件里的 @interface 以及实现文件里的 @implementation 一起形成一个完整的类，extension 伴随类的产生而产生，亦随之一起消亡。  category 中的方法是在运行时决议的，没有实现也可以运行，而 extension 中的方法是在编译期检查的，没有实现会报错。
3. extension 一般用来隐藏类的私有信息，无法直接为系统的类扩展，但可以先创建系统类的子类再添加 extension。 
4. category 可以给系统提供的类添加分类。
5. extension 和 category 都可以添加属性，但是 category 中的属性不能生成对应的成员变量以及 getter 和 setter 方法的实现。
6. extension 不能像 category 那样拥有独立的实现部分（@implementation 部分），extension 所声明的方法必须依托对应类的实现部分来实现。

***

## 65. Category 的一些作用与特点。
&emsp;category 是 Objective-C 2.0 之后添加的语言特性，**它可以在不改变或不继承原类的情况下，动态地给类添加方法**。除此之外还有一些其他的应用场景:
1. 可以把类的的实现分开在几个不同的文件里面。这样做有几个显而易见的好处：
  + 可以减少单个文件的体积。
  + 可以把不同的功能组织到不同的 category 里面。
  + 可以由多个开发者共同完成一个类。
  + 可以按需加载想要的 category。
  + 声明私有方法。
2. 另外还衍生出 category 其他几个场景:
  + 模拟多继承（另外可以模拟多继承的还有 protocol）。
  + 把 framework 的私有方法公开。
  
&emsp;category 的一些特点：
1. category 只能给某个已有的类扩充方法，不能扩充成员变量。
2. category 中也可以添加属性，只不过 @property 只会生成 setter 和 getter 的声明，不会生成 setter 和 getter 的实现以及成员变量。
3. 如果 category 中的方法和类中的原用方法同名，运行时会优先调用 category 中的方法，也就是，category 中的方法会覆盖掉类中原有的方法，所以开发中尽量保证不要让分类中的方法和原有类中的方法名相同，避免出现这种情况的解决方案是给类的方法名统一添加前缀，比如 category_。
4. 如果多个 category 中存在同名的方法，运行时到底调用哪个方法由编译顺序决定，最后一个参与编译的方法会被调用。我们可以在 Compile Sources 中拖动不同分类的顺序来测试。
5. 调用优先级，category > 本类 > 父类。即优先调用 category 中的方法，然后调用本类方法，最后调用父类方法。注意：category 是在运行时添加的，不是在编译时。

注意：
+ category 的方法没有 “完全替换掉” 原来类已经有的方法，也就是说如果 category 和原来类都有 methodA，那么 category 附加完成之后，类的方法列表里会有两个 methodA。
+ category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的 category 的方法会 “覆盖” 掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休，殊不知后面可能还有一样名字的方法。

***

## 66. Category 中能添加属性吗？
&emsp;category 不能添加成员变量（instance variables），那到底能不能添加属性（@property）呢？下面从 category 的结构体开始分析，category_t 定义:
```c++
// classref_t is unremapped class_t*
typedef struct classref * classref_t;

struct category_t {
    const char *name; // 分类的名字
    classref_t cls; // 所属的类 
    struct method_list_t *instanceMethods; // 实例方法列表
    struct method_list_t *classMethods; // 类方法列表
    struct protocol_list_t *protocols; // 协议列表
    struct property_list_t *instanceProperties; // 实例属性列表
    
    // Fields below this point are not always present on disk.
    struct property_list_t *_classProperties; // 类属性列表
    
    // 返回 类/元类 方法列表
    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }

    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
    
    // 协议列表，元类没有协议列表
    protocol_list_t *protocolsForMeta(bool isMeta) {
        // 这里如果是元类的话会返回 nullptr，但是在 load_categories_nolock 函数中有貌似把 protocols 添加到元类的迹象，
        // 但是在 attachCategories 函数中 protocolsForMeta 函数返回 nullptr，应该是没有实际添加。
        if (isMeta) return nullptr;
        else return protocols;
    }
};

/*
* category_t::propertiesForMeta
* 返回 category 的 实例 或 类 的属性。
* hi 是包含 category 的镜像（images）。
*/
property_list_t *
category_t::propertiesForMeta(bool isMeta, struct header_info *hi)
{
    if (!isMeta) return instanceProperties; // 返回实例属性
    else if (hi->info()->hasCategoryClassProperties()) return _classProperties; // 返回类属性
    else return nil; // 其他情况返回 nil
}
```
&emsp;从 category 定义中可以看出 category 可以添加实例方法、类方法也可以实现协议、添加属性，同时也看到不能添加成员变量。那为什么说不能添加属性呢？实际上，category 允许添加属性，可以使用 @property 添加，但是能添加 @property 不代表可以添加 “完整版的” 属性，通常我们说的添加属性是指编译器为我们生成了对应的成员变量和对应的 setter 和 getter 方法来存取属性。在 category 中虽说可以书写 @property，但是不会生成 \_成员变量，也不会生成所添加属性的 getter 和 setter 方法的实现，所以尽管添加了属性，也无法使用点语法调用 setter 和 getter 方法。（实际上，点语法可以写，只不过在运行时调用到这个方法时会报找不到方法的错误直接 crash: unrecognized selector sent to instance ....）。我们此时可以通过 Associated object 来为属性手动实现 setter 和 getter 存取方法。

&emsp;这时我们大概会有一个疑问，这些准备好的的 \_category_t 数据什么时候附加到类上去呢？或者是存放在内存哪里等着我们去调用它里面的实例函数或类函数呢？**已知分类数据是会全部追加到类本身上去的。** 不是类似 weak 机制或者 Associated object 机制等，再另外准备哈希表存放数据，然后根据对象地址去读取处理数据等这样的模式。

&emsp;下面我们就开始研究分类的数据是如何追加到本类上去的。

&emsp;category 的加载涉及到 runtime 的初始化及加载流程且内容实在过于多，这里只是粗略的介绍下，关于 runtime 加载流程的详细内容准备开新篇来讲。本篇只研究 runtime 初始化加载过程中涉及的 category 的加载。Objective-C 的运行是依赖 runtime 来做的，而 runtime 和其他系统库一样，是由 macOS 和 iOS 通过 dyld（the dynamic link editor）来动态加载的。





## 🎉🎉🎉 未完待续...
