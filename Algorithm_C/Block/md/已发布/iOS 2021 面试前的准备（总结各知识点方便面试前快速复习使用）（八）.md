#  iOS 2021 面试前的准备（总结各知识点方便面试前快速复习使用）（八）

## 64. extension 和 cateogry 区别。
1. extension 可以添加成员变量，category 不能添加成员变量。运行时加载类到内存以后，才会加载分类，这时类的内存布局已经确定（编译器还会对成员变量顺序做出优化，保证遵循内存对齐原则下类占用内存容量最少），如果再去添加成员变量就会破坏类的内存布局。各个成员变量的访问地址是在编译时确定的，每个成员变量的地址偏移都是固定的（相对于类的起始地址的内存偏移（硬编码））。
2. extension 在编译期决议（就确定了是类的一部分），category 在运行期决议。extension 在编译期和头文件里的 @interface 以及实现文件里的 @implementation 一起形成一个完整的类，extension 伴随类的产生而产生，亦随之一起消亡。  category 中的方法是在运行时决议的，没有实现也可以运行，而 extension 中的方法是在编译期检查的，没有实现会报错。
3. extension 一般用来隐藏类的私有信息，无法直接为系统的类扩展，但可以先创建系统类的子类再添加 extension。 
4. category 可以给系统提供的类添加分类。
5. extension 和 category 都可以添加属性，但是 category 中的属性不能生成对应的成员变量以及 getter 和 setter 方法的实现。
6. extension 不能像 category 那样拥有独立的实现部分（@implementation 部分），extension 所声明的方法必须依托对应类的实现部分来实现。

***

## 65. Category 的一些作用与特点。
&emsp;category 是 Objective-C 2.0 之后添加的语言特性，**它可以在不改变或不继承原类的情况下，动态地给类添加方法**。除此之外还有一些其他的应用场景:
1. 可以把类的的实现分开在几个不同的文件里面。这样做有几个显而易见的好处：
  + 可以减少单个文件的体积。
  + 可以把不同的功能组织到不同的 category 里面。
  + 可以由多个开发者共同完成一个类。
  + 可以按需加载想要的 category。
  + 声明私有方法。
2. 另外还衍生出 category 其他几个场景:
  + 模拟多继承（另外可以模拟多继承的还有 protocol）。
  + 把 framework 的私有方法公开。
  
&emsp;category 的一些特点：
1. category 只能给某个已有的类扩充方法，不能扩充成员变量。
2. category 中也可以添加属性，只不过 @property 只会生成 setter 和 getter 的声明，不会生成 setter 和 getter 的实现以及成员变量。
3. 如果 category 中的方法和类中的原用方法同名，运行时会优先调用 category 中的方法，也就是，category 中的方法会覆盖掉类中原有的方法，所以开发中尽量保证不要让分类中的方法和原有类中的方法名相同，避免出现这种情况的解决方案是给类的方法名统一添加前缀，比如 category_。
4. 如果多个 category 中存在同名的方法，运行时到底调用哪个方法由编译顺序决定，最后一个参与编译的方法会被调用。我们可以在 Compile Sources 中拖动不同分类的顺序来测试。
5. 调用优先级，category > 本类 > 父类。即优先调用 category 中的方法，然后调用本类方法，最后调用父类方法。注意：category 是在运行时添加的，不是在编译时。

注意：
+ category 的方法没有 “完全替换掉” 原来类已经有的方法，也就是说如果 category 和原来类都有 methodA，那么 category 附加完成之后，类的方法列表里会有两个 methodA。
+ category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的 category 的方法会 “覆盖” 掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休，殊不知后面可能还有一样名字的方法。

***

## 66. Category 中能添加属性吗？
&emsp;category 不能添加成员变量（instance variables），那到底能不能添加属性（@property）呢？下面从 category 的结构体开始分析，category_t 定义:
```c++
// classref_t is unremapped class_t*
typedef struct classref * classref_t;

struct category_t {
    const char *name; // 分类的名字
    classref_t cls; // 所属的类 
    struct method_list_t *instanceMethods; // 实例方法列表
    struct method_list_t *classMethods; // 类方法列表
    struct protocol_list_t *protocols; // 协议列表
    struct property_list_t *instanceProperties; // 实例属性列表
    
    // Fields below this point are not always present on disk.
    struct property_list_t *_classProperties; // 类属性列表
    
    // 返回 类/元类 方法列表
    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }

    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
    
    // 协议列表，元类没有协议列表
    protocol_list_t *protocolsForMeta(bool isMeta) {
        // 这里如果是元类的话会返回 nullptr，但是在 load_categories_nolock 函数中有貌似把 protocols 添加到元类的迹象，
        // 但是在 attachCategories 函数中 protocolsForMeta 函数返回 nullptr，应该是没有实际添加。
        if (isMeta) return nullptr;
        else return protocols;
    }
};

/*
* category_t::propertiesForMeta
* 返回 category 的 实例 或 类 的属性。
* hi 是包含 category 的镜像（images）。
*/
property_list_t *
category_t::propertiesForMeta(bool isMeta, struct header_info *hi)
{
    if (!isMeta) return instanceProperties; // 返回实例属性
    else if (hi->info()->hasCategoryClassProperties()) return _classProperties; // 返回类属性
    else return nil; // 其他情况返回 nil
}
```
&emsp;从 category 定义中可以看出 category 可以添加实例方法、类方法也可以实现协议、添加属性，同时也看到不能添加成员变量。那为什么说不能添加属性呢？实际上，category 允许添加属性，可以使用 @property 添加，但是能添加 @property 不代表可以添加 “完整版的” 属性，通常我们说的添加属性是指编译器为我们生成了对应的成员变量和对应的 setter 和 getter 方法来存取属性。在 category 中虽说可以书写 @property，但是不会生成 \_成员变量，也不会生成所添加属性的 getter 和 setter 方法的实现，所以尽管添加了属性，也无法使用点语法调用 setter 和 getter 方法。（实际上，点语法可以写，只不过在运行时调用到这个方法时会报找不到方法的错误直接 crash: unrecognized selector sent to instance ....）。我们此时可以通过 Associated object 来为属性手动实现 setter 和 getter 存取方法。

***

## 67. attachLists Category 数据追加到原类中去。
&emsp;这时我们大概会有一个疑问，这些定义好的 \_category_t 数据什么时候附加到类上去呢？或者是存放在内存哪里等着我们去调用它里面的实例函数或类函数呢？**已知分类数据是会全部追加到类本身上去的。** 不是类似 weak 机制或者 Associated object 机制等，再另外准备哈希表存放数据，然后根据对象地址去读取处理数据等这样的模式。

&emsp;下面我们就开始研究分类的数据是如何追加到本类上去的。

&emsp;category 的加载涉及到 runtime 的初始化及加载流程且内容实在过于多，这里只是粗略的了解下。此处只研究 runtime 初始化加载过程中涉及的 category 的加载。Objective-C 的运行是依赖 runtime 来做的，而 runtime 和其他系统库一样，是由 macOS 和 iOS 通过 dyld（the dynamic link editor）来动态加载的。

&emsp;category 中的协议会同时添加到类和元类。objc::unattachedCategories.addForClass(lc, cls) 可理解为操作 key 是 cls、value 是 category_list 的哈希表，当前 cls 还没有实现，那这些 category 的内容什么时候附加到类上的。在上一节我们看 UnattachedCategories 数据结构时，看到 attachToClass 函数就是做这个事情的，把事先保存的 category 数据附加到 cls 上。全局搜索，我们可以发现 attachToClass 只会在 methodizeClass 里面调用，然后全局搜索 methodizeClass 函数，发现只有在 realizeClassWithoutSwift 中调用它。

```c++
void attachLists(List* const * addedLists, uint32_t addedCount) {
    if (addedCount == 0) return;

    if (hasArray()) {
        // many lists -> many lists
        
        // 记录之前的长度
        uint32_t oldCount = array()->count;
        uint32_t newCount = oldCount + addedCount;
        
        // realloc 原型: extern void *realloc(void *mem_address, unsigned int newsize);
        // 指针名 =（数据类型*）realloc（要改变内存大小的指针名，新的大小）
        // 返回值: 如果重新分配成功则返回指向被分配内存的指针，否则返回空指针 NULL
        
        // 先判断当前的指针是否有足够的连续空间，如果有，扩大 mem_address 指向的地址，
        // 并且将 mem_address 返回，如果空间不够，先按照 newsize 指定的大小分配空间，
        // 将原有数据从头到尾拷贝到新分配的内存区域，
        // 而后释放原来 mem_address 所指内存区域（注意：原来指针是自动释放，不需要使用 free ），
        // 同时返回新分配的内存区域的首地址，即重新分配存储器块的地址。
        
        // 新的大小 可大可小（如果新的大小大于原内存大小，则新分配部分不会被初始化）
        // 如果新的大小 小于原内存大小，可能会导致数据丢失
        // 注意事项: 
        // 重分配成功旧内存会被自动释放，旧指针变成了野指针，当内存不再使用时，应使用free()函数将内存块释放。
        
        // 扩展空间
        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));
        // 更新 array 长度 
        array()->count = newCount;
        
        // 原型：void *memmove(void* dest, const void* src, size_t count);
        // 由 src 所指内存区域复制 count 个字节到 dest 所指内存区域。
        // memmove 用于拷贝字节，如果目标区域和源区域有重叠的话，
        // memmove 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，
        // 但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和 memcpy 函数功能相同。
        
        // 把方法列表向后移动，给 addedLists 留出空间 addedCount 长的空间
        memmove(array()->lists + addedCount, array()->lists, 
                oldCount * sizeof(array()->lists[0]));
        
        // 原型：void *memcpy(void *destin, void *source, unsigned n);
        // 从源 source 所指的内存地址的起始位置开始拷贝 n 个字节到目标 destin 所指的内存地址的起始位置中
        
        // 把 addedLists 复制到 array()->lists 起始的内存空间
        memcpy(array()->lists, addedLists, 
               addedCount * sizeof(array()->lists[0]));
    }
    else if (!list  &&  addedCount == 1) {
        // 0 lists -> 1 list
        // 如果目前为空，赋值操作（这里是赋值操作，这里是赋值操作）
        list = addedLists[0];
    } 
    else {
        // 1 list -> many lists
        List* oldList = list;
        uint32_t oldCount = oldList ? 1 : 0;
        uint32_t newCount = oldCount + addedCount;
        
        // 扩容
        setArray((array_t *)malloc(array_t::byteSize(newCount)));
        // 更新 count 
        array()->count = newCount;
        // 把 oldList 放在 lists 末尾
        if (oldList) array()->lists[addedCount] = oldList;
        // 把 addedLists 复制到 array()->lists 起始的内存空间
        memcpy(array()->lists, addedLists, 
               addedCount * sizeof(array()->lists[0]));
    }
}
```

***

## 68. +load 函数分析。
+ 实现 load 的分类和类是非懒加载分类和非懒加载类，未实现 +load 函数的分类和类，是懒加载分类和懒加载类。懒加载类只有我们第一次用到它们的时候，才会执行实现。
+ load 函数执行是直接由其函数地址直接调用的，不走 objc_msgSend 的函数查找流程的，所以类和分类中的 load 函数是完全不存在 “覆盖” 行为的。它们都会执行，执行的流程的话：首先是 类一定早于分类的，然后父类一定早于子类，分类之间则是谁先编译则谁先执行。（这里刚好和不同分类中的同名函数，后编译的分类中的函数会 “覆盖” 先编译的分类相反。）
+ 正常情况我们都不应该手动调用 load 函数，我们只要要交给系统自己等待调用即可，且全局只会调用一次。

&emsp;void load_images(const char *path __unused, const struct mach_header *mh) 处理由 dyld 映射的给定的镜像中的类和分类中的 +load 函数。extern bool hasLoadMethods(const headerType *mhdr) 判断 mach_header 中是否包含非懒加载的类和分类（即实现了 load 函数的类和分类）。extern void prepare_load_methods(const headerType *mhdr) 调用 load 函数前的准备，取出 mhdr 中的 count 个非懒加载类，循环把不同类的 load 函数添加进全局的 load 方法的数组（loadable_classes）中，且首先递归添加父类的 +load 函数，然后取出分类中的 load 函数添加进全局的 load 方法的数组（loadable_classes）中，从这里已经可以看出 load 函数调用类早于分类，父类早于子类。

&emsp;具体详细的执行流程可参考：[iOS Category 底层实现原理(三)：附加+load函数超详细解析](https://juejin.cn/post/6870436803220865031)

***

## 69. 









## 🎉🎉🎉 未完待续...
